/*

This file is part of Ext JS 4

Copyright (c) 2011 Sencha Inc

Contact:  http://www.sencha.com/contact

GNU General Public License Usage
This file may be used under the terms of the GNU General Public License version 3.0 as published by the Free Software Foundation and appearing in the file LICENSE included in the packaging of this file.  Please review the following information to ensure the GNU General Public License version 3.0 requirements will be met: http://www.gnu.org/copyleft/gpl.html.

If you are unsure which license is appropriate for your use, please contact the sales department at http://www.sencha.com/contact.

*/
Ext.define("Ext.ux.CurrencyField", { // Dead Code. Unrelated to the project
    extend: "Ext.form.field.Number",
    alias: "widget.currencyfield",
    alternateClassName: ["Ext.form.NumberField", "Ext.form.Number"],
    fieldCls: Ext.baseCSSPrefix + "form-field " + Ext.baseCSSPrefix + "form-currency",
    setValue: function(a) {
        this.callParent(arguments);
        if (!Ext.isEmpty(this.getValue())) {
            this.setRawValue(Ext.util.Format.number(this.getValue(), "0,0"))
        }
    },
    removeFormat: function(a) {
        if (Ext.isEmpty(a)) {
            return ""
        } else {
            a = a.toString().replace(/,/g, "");
            if (a % 1 === 0) {
                return Ext.util.Format.number(a, "0")
            } else {
                return Ext.util.Format.number(a, "0.00")
            }
        }
    },
    parseValue: function(a) {
        return this.callParent([this.removeFormat(a)])
    },
    getErrors: function(a) {
        return this.callParent([this.removeFormat(a)])
    },
    getSubmitData: function() {
        var a = {};
        a[this.name] = this.removeFormat(this.callParent(arguments)[this.name]);
        return a
    },
    preFocus: function() {
        this.setRawValue(this.removeFormat(this.getRawValue()));
        this.callParent(arguments)
    }
});
Ext.ns("PSO2");
Ext.define("PSO2.CookieModel", {
    extend: "Ext.data.Model",
    idProperty: "key",
    fields: [{
        name: "key"
    }, {
        name: "value"
    }]
});
PSO2.Cookie = {
    expiresDay: 60,
    version: "1.1",
    vText: "__version",
    init: function() {
        PSO2.Cookie.cookieProvider = Ext.create("Ext.state.CookieProvider", {
            path: location.pathname,
            domain: location.hostname,
            expires: new Date(new Date().getTime() + (86400000 * PSO2.Cookie.expiresDay))
        });
        Ext.state.Manager.setProvider(PSO2.Cookie.cookieProvider)
    },
	// Returns all affix plans saved to the cookie
    get: function(cookieName) {
        if (!Ext.isDefined(PSO2.Cookie.cookieProvider)) {
            PSO2.Cookie.init()
        }
        var tmpPlanList = PSO2.Cookie.cookieProvider.get(cookieName),
            version = PSO2.Cookie.cookieProvider.get(cookieName + PSO2.Cookie.vText),
            savedPlanList = null;
		// Determine how to save the plans
		// If version number is the same, can pass it
		// If not, parse it and pass it
        if (Ext.isDefined(version)) {
            if (version == PSO2.Cookie.version) {
                savedPlanList = tmpPlanList
            }
        } else {
            try {
                savedPlanList = JSON.parse(tmpPlanList)
            } catch (d) {}
        }
        return savedPlanList
    },
    set: function(cookieName, savedPlanList) {
        if (!Ext.isDefined(PSO2.Cookie.cookieProvider)) {
            PSO2.Cookie.init()
        }
        if (Ext.isObject(savedPlanList)) {
            PSO2.Cookie.cookieProvider.set(cookieName, savedPlanList);
            PSO2.Cookie.cookieProvider.set(cookieName + PSO2.Cookie.vText, PSO2.Cookie.version)
        }
    }
};
PSO2.utils = {
    overflow: function(a, c, b) {
        if (a < c) {
            return a - 1
        }
        return Math.max(0, c - b)
    }
};
Ext.ns("PSO2");
Ext.define("PSO2.CostPanel", {
    extend: "Ext.panel.Panel",
    alias: "widget.costpanel",
    layout: "anchor",
    baseCls: Ext.baseCSSPrefix + "panel-body-default-framed " + Ext.baseCSSPrefix + "costpanel",
    xtype: "costpanel",
    padding: "0 5px 0 5px",
    autoHeight: true,
    border: 0,
    frame: false,
    constCookieName: "pso2cost",
    defaults: {
        anchor: "100%"
    },
    precision: 5,
    sequenceNumber: 0,
    maxMaterial: 5,
    ddGroup: "cost",
    constCostField: "-fl-",
    constResultPanel: "-rp",
    constRPCheckbox: "-chk",
    constRPTotal: "-total",
    constRPCost: "-cost",
    constRPExpectation: "-exp",
    constRequire: "-require",
    referenceClass: "x-reference-field",
    initComponent: function() {
        var a = this;
        if (a.tabPanel) {
            a.tabPanel.on("beforeadd", a.addTabPanel, a);
            a.tabPanel.on("beforeremove", a.removeTabPanel, a)
        }
        a.synthesisParams = {};
        a.referenceFields = {};
        a.referencePanels = {};
        a.referenceSets = {};
        a.referenceUpdate = false;
        a.callParent(arguments)
    },
    initItems: function() {
        var f = this,
            c = PSO2.Cookie.get(f.constCookieName) || {},
            e = [],
            b, d = f.supportData,
            a = f.additionalData;
        for (b = 1; b < d.length; b++) {
            e.push({
                id: f.id + f.constCostField + d[b].value,
                name: d[b].value,
                fieldLabel: d[b].name,
                value: c[d[b].value] || 0,
                listeners: {
                    scope: f,
                    change: f.changeOptionCost
                }
            })
        }
        for (b = 1; b < a.length; b++) {
            e.push({
                id: f.id + f.constCostField + a[b].value,
                name: a[b].value,
                fieldLabel: a[b].name,
                value: c[a[b].value] || 0,
                listeners: {
                    scope: f,
                    change: f.changeOptionCost
                }
            })
        }
        e.push({
            id: f.id + f.constRequire,
            name: f.constRequire,
            fieldLabel: "Cost of Synthesis",
            value: c[f.constRequire] || 0,
            step: 1000,
            listeners: {
                scope: f,
                change: f.changeOptionCost
            }
        });
        e.push({
            xtype: "button",
            text: "Save",
            scope: f,
            handler: function() {
                var h = this,
                    g = {};
                h.costFieldSet.items.each(function(k) {
                    if (k.xtype != "button") {
                        g[k.name] = k.getValue()
                    }
                });
                PSO2.Cookie.set(h.constCookieName, g);
                Ext.Msg.alert("Information", "Cookies must be enabled.")
            }
        });
        f.costFieldSet = Ext.create("Ext.form.FieldSet", {
            title: "Set Cost",
            frame: true,
            layout: "anchor",
            collapsible: true,
            padding: "5px",
            defaultType: "currencyfield",
            defaults: {
                width: 300,
                labelWidth: 140,
                labelAlign: "right",
                minValue: 0,
                fieldStyle: "text-align:right",
                step: 1050
            },
            items: e
        });
        f.synthesisPanel = Ext.create("Ext.panel.Panel", {
            frame: false,
            border: 0,
            padding: "0",
            autoHeight: true,
            layout: "anchor",
            defaults: {
                xtype: "panel",
                baseCls: Ext.baseCSSPrefix + "panel-body-default-framed " + Ext.baseCSSPrefix + "cost-field",
                frame: false,
                padding: "0",
                border: 0
            }
        });
        if (f.tabPanel) {
            for (var b = 0; b < f.tabPanel.items.length; b++) {
                f.addCost(f.tabPanel.items.getAt(b))
            }
        }
        f.items = [f.costFieldSet, Ext.create("Ext.panel.Panel", {
            frame: false,
            border: 0,
            items: [f.synthesisPanel]
        })];
        f.callParent(arguments)
    },
    addCost: function(h) {
        var l = this,
            g = h.getResultPanel(),
            a = l.getCost(h, g),
            c = l.getExpectation(h, g, a),
            d = !g.isDodo(),
            f = g.id + l.constResultPanel,
            k = [{
                name: g.id + l.constResultPanel + "-cur-0",
                fieldLabel: "Fodder"
            }],
            b, e;
        for (e = 1; e <= l.maxMaterial; e++) {
            k.push({
                name: g.id + l.constResultPanel + "-cur-" + e,
                fieldLabel: "Fodder" + e
            })
        }
        b = l.synthesisPanel.add({
            id: f,
            targetPanel: h,
            items: [{
                xtype: "container",
                layout: {
                    type: "hbox",
                    autoFlex: false
                },
                defaults: {
                    style: "margin-right:5px"
                },
                items: [{
                    xtype: "button",
                    text: "Panel No." + (++l.sequenceNumber),
                    scope: l,
                    handler: function() {
                        l.tabPanel.setActiveTab(h)
                    }
                }, {
                    id: f + l.constRPTotal,
                    frame: true,
                    border: 1,
                    width: 160,
                    style: {
                        textAlign: "right"
                    },
                    html: l.getSuccess(h, g)
                }]
            }, {
                xtype: "container",
                layout: {
                    type: "hbox"
                },
                defaults: {
                    xtype: "currencyfield",
                    labelWidth: 42,
                    labelAlign: "right",
                    flex: 1,
                    minValue: 0,
                    fieldStyle: "text-align:right",
                    margin: "4px 0 4px 0px",
                    step: 1050,
                    value: 0,
                    disabled: d,
                    listeners: {
                        scope: l,
                        change: l.changeMainCost,
                        render: l.initializeCostDropZone
                    }
                },
                items: k
            }, {
                xtype: "container",
                layout: {
                    type: "hbox",
                    autoFlex: false
                },
                padding: "0",
                defaults: {
                    width: 200,
                    border: 0,
                    frame: false,
                    margin: "0 0 0 8px"
                },
                items: [{
                    xtype: "checkbox",
                    disabled: d,
                    style: {
                        textAlign: "right"
                    },
                    listeners: {
                        scope: l,
                        change: l.changeSynthesisCost
                    }
                }, {
                    id: f + l.constRPCost,
                    parentId: f,
                    frame: true,
                    border: 1,
                    autoHeight: true,
                    layout: "fit",
                    tpl: new Ext.XTemplate(['<div class="x-cost-frame">', '<div class="x-cost-label">Expense:</div>', '<div class="x-cost-value">{text}</div>', "</div>", '<div style="clear:both"></div>']),
                    style: {
                        textAlign: "right"
                    },
                    data: {
                        value: a,
                        text: Ext.util.Format.number(a, "0,0")
                    },
                    update: function(m) {
                        this.data = {
                            value: m,
                            text: Ext.util.Format.number(m, "0,0")
                        };
                        this.tpl.overwrite(this.body, this.data)
                    }
                }, {
                    id: f + l.constRPExpectation,
                    parentId: f,
                    frame: true,
                    border: 1,
                    layout: "fit",
                    tpl: new Ext.XTemplate(['<div class="x-cost-frame">', '<img class="x-cost-drag-icon">', '<div class="x-cost-label">Expense:</div>', '<div class="x-cost-value">{text}</div>', "</div>", '<div style="clear:both"></div>']),
                    style: {
                        textAlign: "right"
                    },
                    itemSelector: ".x-cost-drag-icon",
                    listeners: {
                        scope: l,
                        render: l.initializeCostDragZone
                    },
                    data: {
                        value: c,
                        text: Ext.util.Format.number(c, "0,0")
                    },
                    update: function(m) {
                        this.data = {
                            value: m,
                            text: Ext.util.Format.number(m, "0,0")
                        };
                        this.tpl.overwrite(this.body, this.data);
                        this.fireEvent("update", this, m, this.data, l)
                    }
                }]
            }]
        });
        if (h.rendered !== true) {
            h.on("afterrender", l.tabAfterRender, l)
        }
        l.synthesisParams[h.id] = {
            number: l.sequenceNumber,
            panel: b,
            totalPanel: Ext.getCmp(f + l.constRPTotal),
            costPanel: Ext.getCmp(f + l.constRPCost),
            expPanel: Ext.getCmp(f + l.constRPExpectation),
            cost: a,
            exp: c
        };
        g.on("dodochange", l.changeResult, l);
        g.on("opt1change", l.changeSuccess, l);
        g.on("opt2change", l.changeSuccess, l);
        g.on("successchange", l.changeSuccess, l)
    },
    getSynthesisParams: function(a, c) {
        var b = this,
            d;
        for (d in b.synthesisParams) {
            if (b.synthesisParams[d][a] === c) {
                return b.synthesisParams[d]
            }
        }
        return false
    },
    checkReference: function(e, d) {
        var c = this,
            b = c.referencePanels[e];
        if (b) {
            for (var a = 0; a < b.length; a++) {
                if (b[a] == d) {
                    return true
                }
                if (c.checkReference(b[a], d)) {
                    return true
                }
            }
        }
        return false
    },
    registReferenceCost: function(c, k) {
        var h = this,
            d = h.getSynthesisParams("expPanel", c),
            f = h.synthesisParams[k.ownerCt.ownerCt.targetPanel.id],
            g;
        g = h.checkReference(d.number, f.number);
        if (g) {
            Ext.Msg.alert("Warning", "Since the circular reference occurs, it could not continue processing.");
            return false
        }
        if (h.referenceFields[k.id]) {
            if (h.referenceFields[k.id] == c) {
                return false
            }
            var a = h.getSynthesisParams("expPanel", h.referenceFields[k.id]).number,
                b = h.referencePanels[f.number],
                e = Ext.Array.indexOf(b, a);
            b.splice(e, 1);
            h.referenceSets[f.number + "-" + a] -= 1;
            h.referenceFields[k.id].un({
                scope: k,
                update: h.updateReferenceCost
            });
            Ext.QuickTips.unregister(k.getEl())
        }
        if (h.referencePanels[f.number]) {
            if (Ext.Array.indexOf(h.referencePanels[f.number], d.number) < 0) {
                h.referencePanels[f.number].push(d.number)
            }
            if (h.referenceSets[f.number + "-" + d.number]) {
                h.referenceSets[f.number + "-" + d.number] += 1
            } else {
                h.referenceSets[f.number + "-" + d.number] = 1
            }
        } else {
            h.referencePanels[f.number] = [d.number];
            h.referenceSets[f.number + "-" + d.number] = 1
        }
        c.on({
            scope: k,
            update: h.updateReferenceCost
        });
        h.referenceUpdate = true;
        k.setValue(d.exp);
        h.referenceUpdate = false;
        k.addCls(h.referenceClass);
        Ext.QuickTips.register({
            target: k.getEl(),
            text: "Panel " + d.number + " cost"
        });
        h.referenceFields[k.id] = c;
        return true
    },
    updateReferenceCost: function(d, a, e, b) {
        var c = this;
        b.referenceUpdate = true;
        c.setValue(a);
        b.referenceUpdate = false
    },
    initializeCostDragZone: function(a) {
        var b = this;
        if (b.noDD != true) {
            a.dragZone = Ext.create("Ext.dd.DragZone", a.getEl(), {
                ddGroup: b.ddGroup,
                getDragData: function(f) {
                    var c = f.getTarget(a.itemSelector, 10),
                        g;
                    if (c) {
                        g = c.cloneNode(true);
                        g.id = Ext.id();
                        return a.dragData = {
                            sourceEl: c,
                            repairXY: Ext.fly(c).getXY(),
                            ddel: g,
                            costPanel: a.ownerCt.ownerCt
                        }
                    }
                },
                getRepairXY: function() {
                    return this.dragData.repairXY
                }
            })
        }
    },
    initializeCostDropZone: function(a) {
        var b = this,
            c = b;
        if (b.noDD != true) {
            a.dropZone = Ext.create("Ext.dd.DropZone", a.el, {
                ddGroup: b.ddGroup,
                getTargetFromEvent: function(d) {
                    return d.getTarget(".x-form-currency")
                },
                onNodeDrop: function(l, f, k, h) {
                    var g = this,
                        d = a.ownerCt.ownerCt;
                    if (h.costPanel.id == d.id) {
                        return false
                    }
                    if (d.targetPanel.rendered !== true) {
                        return false
                    }
                    return c.registReferenceCost(Ext.getCmp(f.id), a)
                }
            })
        }
    },
    getSuccess: function(a, b) {
        return a.rendered ? Ext.util.Format.round(b.totalValue, this.precision) + "%" : "Please press the panel"
    },
    getCost: function(c, d) {
        var e = this,
            b = 0,
            f, a;
        if (c.rendered) {
            f = d.selectedOptions();
            Ext.Array.forEach(f, function(g) {
                var h = this.costFieldSet.items.get(e.id + e.constCostField + g);
                if (h) {
                    b += h.value
                }
            }, e);
            if (e.synthesisParams[c.id]) {
                a = e.synthesisParams[c.id].panel.query("checkbox");
                if (a && Ext.isArray(a)) {
                    if (a[0].checked) {
                        b += e.costFieldSet.items.get(e.id + e.constRequire).value
                    }
                }
            }
        }
        return b
    },
    getExpectation: function(b, c, g) {
        var d = this,
            f = d.synthesisParams[b.id],
            a = 0,
            e = 0;
        if (b.rendered && 0 < c.totalValue) {
            e += g;
            if (f && f.panel) {
                Ext.Array.forEach(f.panel.query("currencyfield"), function(h) {
                    e += h.value
                })
            }
            a = e * (100 / c.totalValue)
        }
        return a
    },
    changeMainCost: function(k) {
        var g = this,
            e = k.ownerCt.ownerCt.targetPanel,
            d = e.getResultPanel(),
            c = g.synthesisParams[e.id];
        if (g.referenceUpdate !== true && g.referenceFields[k.id]) {
            var a = g.synthesisParams[k.ownerCt.ownerCt.targetPanel.id].number,
                h = g.getSynthesisParams("expPanel", g.referenceFields[k.id]).number;
            g.referenceFields[k.id].un({
                scope: k,
                update: g.updateReferenceCost
            });
            k.removeCls(g.referenceClass);
            Ext.QuickTips.unregister(k.getEl());
            g.referenceSets[a + "-" + h] -= 1;
            if (g.referenceSets[a + "-" + h] <= 0) {
                var b = g.referencePanels[a],
                    f = Ext.Array.indexOf(b, h);
                b.splice(f, 1);
                delete g.referenceSets[a + "-" + h]
            }
            delete g.referenceFields[k.id]
        }
        c.exp = g.getExpectation(e, d, c.cost);
        c.expPanel.update(c.exp)
    },
    changeSynthesisCost: function(f, a, c) {
        var e = this,
            b = f.ownerCt.ownerCt.targetPanel,
            d = b.getResultPanel(),
            g = e.synthesisParams[b.id];
        g.cost = e.getCost(b, d);
        g.costPanel.update(g.cost);
        g.exp = e.getExpectation(b, d, g.cost);
        g.expPanel.update(g.exp)
    },
    changeOptionCost: function() {
        var c = this,
            e;
        for (e in c.synthesisParams) {
            var a = Ext.getCmp(e),
                b = a.getResultPanel(),
                d = c.synthesisParams[e];
            d.cost = c.getCost(a, b);
            d.costPanel.update(d.cost);
            d.exp = c.getExpectation(a, b, d.cost);
            d.expPanel.update(d.exp)
        }
    },
    tabAfterRender: function(a) {
        var c = this,
            b = a.getResultPanel();
        c.changeResult(b);
        c.changeSuccess(b);
        a.un("afterrender", c.tabAfterRender, c)
    },
    removeCost: function(g) {
        var m = this,
            e = g.getResultPanel(),
            c = m.synthesisParams[g.id],
            a = c.panel;
        e.un("dodochange", m.changeResult, m);
        e.un("opt1change", m.changeSuccess, m);
        e.un("opt2change", m.changeSuccess, m);
        e.un("successchange", m.changeSuccess, m);
        var h = m.synthesisParams[g.id].panel.query("currencyfield");
        Ext.Array.forEach(h, function(f) {
            if (m.referenceFields[f.id]) {
                m.referenceFields[f.id].un({
                    scope: f,
                    update: m.updateReferenceCost
                });
                delete m.referenceFields[f.id]
            }
            Ext.QuickTips.unregister(f.getEl())
        }, m);
        for (var l in m.referenceFields) {
            if (m.referenceFields[l] == c.expPanel) {
                var n = Ext.getCmp(l);
                n.removeCls(m.referenceClass);
                Ext.QuickTips.unregister(n.getEl());
                delete m.referenceFields[l]
            }
        }
        delete m.referencePanels[c.number];
        delete m.synthesisParams[g.id];
        for (var d in m.referencePanels) {
            var b = m.referencePanels[d];
            if (b) {
                var k = Ext.Array.indexOf(b, c.number);
                if (0 <= k) {
                    b.splice(k, 1)
                }
            }
        }
        m.synthesisPanel.remove(a, true)
    },
    addTabPanel: function(c, a, b) {
        var d = this;
        if (a.title && a.title != d.title) {
            d.addCost(a)
        }
    },
    removeTabPanel: function(b, a) {
        var c = this;
        if (a.title && a.title != c.title) {
            c.removeCost(a)
        }
    },
    changeResult: function(e) {
        var f = this,
            c = e.ownerCt.ownerCt,
            b = f.synthesisParams[c.id].panel,
            g = b.query("currencyfield"),
            a = b.query("checkbox"),
            d;
        if (e.isDodo()) {
            for (d = 0; d < g.length; d++) {
                g[d].enable()
            }
            for (d = 0; d < a.length; d++) {
                a[d].enable()
            }
        } else {
            for (d = 0; d < g.length; d++) {
                g[d].disable()
            }
            for (d = 0; d < a.length; d++) {
                a[d].disable()
            }
        }
    },
    changeSuccess: function(b) {
        var c = this,
            a = b.ownerCt.ownerCt,
            d = c.synthesisParams[a.id];
        d.totalPanel.update(Ext.util.Format.round(b.totalValue, c.precision) + "%");
        d.cost = c.getCost(a, b);
        d.costPanel.update(d.cost);
        d.exp = c.getExpectation(a, b, d.cost);
        d.expPanel.update(d.exp)
    },
    destroy: function() {
        var a = this;
        for (id in a.synthesisParams) {
            a.removeCost(Ext.getCmp(id))
        }
        a.tabPanel.un("beforeadd", a.addTabPanel, a);
        a.tabPanel.un("beforeremove", a.removeTabPanel, a);
        a.callParent(arguments)
    }
});
Ext.ns("PSO2");
Ext.define("PSO2.Ability", {
    extend: "Ext.data.Model",
    fields: ["code", "gid", "name", "lvup", "extend", "generate", "require", "extup", "status", "effect"]
});
Ext.define("PSO2.Slot", {
    extend: "Ext.data.Model",
    fields: ["id", "name", "slot"]
});
Ext.define("PSO2.AbilitySet", {
    extend: "Ext.Base",
    mutationICd: "OA01",
    mutationIICd: "OA02",
    photonCd: "WA01",
	// Constucts the ability set for the panel
    constructor: function(abilitySet) {
        var b = this,
            affixEntry;
        Ext.apply(b, abilitySet);
		// Find id of Mutation I, Mutation II, and Photon Collect for boost upgrade calculations
        if (b.abilityStore) {
            affixEntry = b.abilityStore.findRecord("name", "Mutation I");
            if (affixEntry) {
                b.mutationICd = affixEntry.get("code")
            }
            affixEntry = b.abilityStore.findRecord("name", "Mutation II");
            if (affixEntry) {
                b.mutationIICd = affixEntry.get("code")
            }
            affixEntry = b.abilityStore.findRecord("name", "Photon Collect");
            if (affixEntry) {
                b.photonCd = affixEntry.get("code")
            }
        }
        b.stores = [];
        b.clear()
    },
	// Returns list of affixes on the fodder
    getEnableData: function(fodId) {
        return this.stores[fodId].getEnableData()
    },
	// Returns count of SAF on the fodder
    getFactorCount: function(fodId) {
        return this.stores[fodId].getFactorCount()
    },
	// Returns list of id on the fodder
    getLocationHash: function(fodId) {
        var panel = this,
            fodder = panel.stores[fodId],
            codeList = "";
        if (fodder) {
            codeList = fodder.getEnableDataCd()
        }
        return codeList
    },
	// Push a fodder into the fodder list. True if has not existed
    putStore: function(store) {
        var a = (Ext.Array.indexOf(this.stores, store) < 0);
        if (a) {
            this.stores.push(store)
        }
        return a
    },
	// Push affix onto processing stack?
    put: function(affix) {
        var panel = this,
            c, b = affix;
        if (!panel.hashStack[affix.code]) {
            panel.hashStack[affix.code] = 0
        }
        c = ++panel.hashStack[affix.code];
        if (Ext.isArray(affix.extend)) {
            if (0 < affix.extend[panel.overflow(affix.extend.length, c, 1)] && Ext.Array.indexOf(d.stack, affix) < 0) {
                panel.stack.push(affix)
            }
        }
    },
	// Returns true if exists in the panel
    isMutationI: function() {
        var panel = this;
        return 0 < panel.hashStack[panel.mutationICd]
    },
    isMutationII: function() {
        var panel = this;
        return 0 < panel.hashStack[panel.mutationIICd]
    },
    isPhotonCollect: function() {
        var panel = this;
        return 0 < panel.hashStack[panel.photonCd]
    },
	// Number of material being used
    enableMaterial: function() {
        var panel = this,
            len = panel.stores.length,
            c = 0,
            b;
        for (b = 1; b < len; b++) {
            if (panel.stores[b].exist()) {
                c++
            }
        }
        return c
    },
	// Returns the max amount of slots can be used
    enableMaterialMaxCount: function() {
        return Math.min(this.enableCheckMax, this.stores[0].count() - 1)
    },
    forEach: function(func, resultPanel) { // Called by ln 1746
        var panel = this,
            resultPanel = [],
            e;
        for (e in panel.hashStack) {
            resultPanel.push(e)
        }
        for (e in panel.levelupHashStack) {
            resultPanel.push(e)
        }
        for (e in panel.refHashStack) {
            resultPanel.push(e)
        }
        resultPanel = resultPanel.filter(function(f, h, g) {
            return g.indexOf(f) === h
        }).sort();
        for (i = 0; i < resultPanel.length; i++) {
            if (resultPanel[i]) {
                if (resultPanel[i].substr(0, 1) == "*") {
                    func.call(resultPanel, panel.abilityStore.findRecord("code", resultPanel[i].substr(1))["data"], true)
                } else {
                    func.call(resultPanel, panel.abilityStore.findRecord("code", resultPanel[i])["data"], false)
                }
            }
        }
    },
    // Resets the panel and calculates if the setup is valid
    // and produces the list of possible affixes
    resetAbility: function() {
        var panel = this,
            numFod = panel.stores.length,
            minAffix = panel.getEnableData(0).length - panel.getFactorCount(0),
            b;
        if (minAffix == 0) {
            b = false;
            for (i = 1; i < numFod; i++) {
                if (0 < panel.getEnableData(i).length) {
                    b = true;
                    break
                }
            }
        } else {
            b = true;
            for (i = 1; i < numFod; i++) {
                var affixCount = panel.getEnableData(i).length - panel.getFactorCount(i);
                if (0 < affixCount && affixCount < minAffix) {
                    b = false;
                    break
                }
            }
        }
        panel.clear();
        if (b == true) {
            for (i = 0; i < numFod; i++) {
                Ext.Array.forEach(panel.getEnableData(i), panel.put, panel)
            }
            panel.enableCheckMax = minAffix + 1;
            panel.resetLevelupAbility();
            panel.resetExtendAbility()
        }
    },
    clear: function() {
        var panel = this;
        panel.enableCheckMax = 0;
        panel.stack = [];
        panel.hashStack = {};
        panel.levelupStack = [];
        panel.levelupHashStack = {};
        panel.exStack = {};
        panel.refStack = [];
        panel.refHashStack = {};
        panel.refBonusStack = {}
    },
    // Returns index of the code in the list
    indexOf: function(listAffix, key, code) {
        var a = listAffix.length,
            index;
        for (index = 0; index < a; index++) {
            if (listAffix[index][key] == code) {
                return index
            }
        }
        return -1
    },
    // Returns list of code of the affixes in the hash stack
    getKeyList: function(hashStack) {
        var arrayCode = [],
            affixCode;
        for (affixCode in hashStack) {
            arrayCode.push(affixCode)
        }
        return arrayCode
    },
    // Finds all valid lvl up affix and push onto levelupStack
    resetLevelupAbility: function() {
        var panel = this,
            arrayCode = panel.getKeyList(panel.hashStack),
            arrayLen = arrayCode.length,
            entryIndex, lvlupCode, index, numCopies, lvlupAffix, baseAffix;
        for (index = 0; index < arrayLen; index++) {
            numCopies = panel.hashStack[arrayCode[index]];
            // If there is more than 1 copy, then it may lvl up
            if (1 < numCopies) {
                entryIndex = panel.indexOf(panel.stack, "code", arrayCode[index]);
                if (0 <= entryIndex) {
                    // Find associate code for lvl up
                    lvlupCode = panel.stack[entryIndex]["lvup"];
                    if (lvlupCode && !panel.levelupHashStack[lvlupCode]) {
                        lvlupAffix = panel.abilityStore.findRecord("code", lvlupCode)["data"];
                        // Determine if it is possible to lvl up with number of copies atm
                        if (lvlupAffix.generate && lvlupAffix.generate[Math.min(lvlupAffix.generate.length - 1, numCopies - 2)]) {
                            // Determine if the base affix has a requirement for lvl up (Gift)
                            // to determine if push onto lvlup stack
                            baseAffix = panel.abilityStore.findRecord("code", arrayCode[index]);
                            if (baseAffix.get("require")) {
                                if (panel.hashStack[baseAffix.get("require")]) {
                                    panel.levelupStack.push(lvlupAffix);
                                    panel.levelupHashStack[lvlupCode] = panel.hashStack[arrayCode[index]]
                                }
                            } else {
                                // Push lvlup Affix and stores the number of copies are being used
                                panel.levelupStack.push(lvlupAffix);
                                panel.levelupHashStack[lvlupCode] = panel.hashStack[arrayCode[index]]
                            }
                        }
                    }
                }
            }
        }
    },
    // Searches for all extendAbility rules and adds affixes to the list according to the rule
    resetExtendAbility: function() {
        var panel = this,
            affixCode, affixEntry;
        // For all affix in the hashstack, check if it has extup rule
        for (affixCode in panel.hashStack) {
            affixEntry = panel.abilityStore.findRecord("code", affixCode);
            if (affixEntry && affixEntry.get("extup")) {
                // Enters all possible relation boost recipe to the list
                Ext.Array.forEach(affixEntry.get("extup"), function(extTarget) {
                    if (!panel.exStack[extTarget]) { // new entry
                        panel.exStack[extTarget] = [affixEntry.get("rel")]
                    } else { // existing
                        panel.exStack[extTarget].push(affixEntry.get("rel"))
                    }
                })
            }
        }
        Ext.Array.forEach(panel.abilityComponent.constExtendAbility, function(relRule) {
            var localPanel = this,
                rulTarget = localPanel.getAbilityRefferer(relRule),
                index, targetIndex;
            // If there are valid targets for the rule
            if (rulTarget) {
                for (index = 0; index < rulTarget.length; index++) {
                    if (relRule.success) {
                        targetIndex = localPanel.indexOf(localPanel.stack, "code", rulTarget[index]);
                        if (targetIndex < 0) {
                            // Target is added to the list due to the rule
                            if (localPanel.indexOf(localPanel.levelupStack, "code", rulTarget[index]) < 0) {
                                localPanel.refStack.push(localPanel.abilityStore.findRecord("code", rulTarget[index])["data"])
                            }
                        }
                        localPanel.refHashStack[rulTarget[index]] = relRule.success
                    } else { // ???
                        if (relRule.bonus) {
                            localPanel.refBonusStack[rulTarget[index]] = relRule.bonus
                        }
                    }
                }
            }
        }, panel)
    },
    // Take extendAbility and searches for all valid targets
    getAbilityRefferer: function(extendAbility) {
        var panel = this,
            base = extendAbility.base,
            baseLength = base.length,
            index, f = true,
            g = null,
            hashStack = Ext.apply({}, panel.hashStack);
        for (index = 0; index < baseLength; index++) {
            if (base[index].indexOf("*") < 0) {
                if (!hashStack[base[index]]) {
                    return null
                } else {
                    hashStack[base[index]]--
                }
            } else {
                var regex = new RegExp("(" + base[index].replace("*", "[^,]+") + ")", "g"),
                    relTarget = panel.getKeyList(hashStack).join(",").match(regex);
                if (relTarget) {
                    g = relTarget
                } else {
                    return null
                }
            }
        }
        return (extendAbility.ref == "$$" && g) ? relTarget : Ext.isArray(extendAbility.ref) ? extendAbility.ref : [extendAbility.ref]
    },
    overflow: function(a, c, b) {
        if (a < c) {
            return a - 1
        }
        return Math.max(0, c - b)
    }
});
Ext.define("PSO2.AbilityStore", {
    extend: "Ext.data.Store",
    model: "PSO2.Ability",
    groupField: "gid",
    findRecord: function() {
        var a = this.callParent(arguments);
        if (a || !this.snapshot) {
            return a
        }
        return this.findRecord2.apply(this, arguments)
    },
    find2: function(e, d, g, f, a, c) {
        var b = this.createFilterFn(e, d, f, a, c);
        return b ? this.snapshot.findIndexBy(b, null, g) : -1
    },
    findRecord2: function() {
        var b = this,
            a = b.find2.apply(b, arguments);
        return a !== -1 ? b.getAt2(a) : null
    },
    getAt2: function(a) {
        return this.snapshot.getAt(a)
    }
});
Ext.define("PSO2.AbilityComponent", {
    extend: "Ext.Base",
    constAbility: [],
    constExtra: [],
    constBoostPoint: {},
    constExtendAbility: [],
    constBaseSlot: [{
        id: "slot01",
        name: "Slot 1",
        slot: null
    }, {
        id: "slot02",
        name: "Slot 2",
        slot: null
    }, {
        id: "slot03",
        name: "Slot 3",
        slot: null
    }, {
        id: "slot04",
        name: "Slot 4",
        slot: null
    }, {
        id: "slot05",
        name: "Slot 5",
        slot: null
    }, {
        id: "slot06",
        name: "Slot 6",
        slot: null
    }, {
        id: "slot07",
        name: "Slot 7",
        slot: null
    }, {
        id: "slot08",
        name: "Slot 8",
        slot: null
    }, {
        id: "slot09",
        name: "Slot 9",
        slot: null
    }],
    excludePattern: [],
    constructor: function(a) {
        Ext.apply(this, a);
        this.callParent(a)
    },
    getAbilityStore: function(a) {
        var b = this;
        if (a === true) {
            return Ext.create("PSO2.AbilityStore", {
                data: b.constAbility
            })
        } else {
            if (!b.abilityStore) {
                b.abilityStore = b.getAbilityStore(true)
            }
        }
        return b.abilityStore
    },
    isExistAbilities: function(c) {
        var e = this,
            b = e.getAbilityStore(),
            a, d;
        if (!Ext.isArray(c)) {
            c = [c]
        }
        a = c.length;
        for (d = 0; d < a; d++) {
            var f = c[d];
            if (f.substr(0, 1) == "*") {
                f = f.substr(1)
            }
            if (0 > b.findBy(function(g) {
                    if (g.data.code == f) {
                        return true
                    }
                })) {
                return false
            }
        }
        return true
    },
    createSlotStore: function() {
        var b = this,
            a = Ext.create("Ext.data.Store", {
                model: "PSO2.Slot",
                data: this.constBaseSlot,
                chkFn: function(h, m) {
                    var g = b.excludePattern,
                        f, e, l, d, k;
                    for (f = 0; f < g.length; f++) {
                        l = Ext.isArray(g[f]) ? g[f] : [g[f]];
                        d = k = false;
                        for (e = 0; e < l.length; e++) {
                            if (l[e] == m.substr(0, l[e].length)) {
                                d = true
                            }
                            if (l[e] == h.substr(0, l[e].length)) {
                                k = true
                            }
                        }
                        if (d && k) {
                            return true
                        }
                    }
                    return false
                },
                addAbility: function(g) {
                    var e = g.code.substr(0, 1) == "*",
                        f = e ? g.code.substr(1) : g.code,
                        h = f.substr(0, 2),
                        k, c = this.getCount(),
                        d;
                    for (d = 0; d < c; d++) {
                        k = this.getAt(d).get("slot");
                        if (k == null) {
                            break
                        }
                        if ((k.source && k.source.code == f) || (k.code == f)) {
                            return true
                        }
                        if ((k.source && k.source.code.substr(0, 2) == h) || (k.code.substr(0, 2) == h)) {
                            if ((k.code.substr(0, 1) != "*")) {
                                break
                            }
                        }
                        if (this.chkFn(g.code, k.code)) {
                            break
                        }
                    }
                    if (c <= d) {
                        return false
                    }
                    return this.getAt(d).set("slot", g)
                },
                exist: function() {
                    return this.getEnableData().length != 0
                },
                swapAbility: function(e, f) {
                    var d = this.getCount(),
                        c, g = 0;
                    if (e == f) {
                        return false
                    }
                    while (g < d && (c = this.getAt(g).get("slot")) != null) {
                        g++
                    }
                    if (g <= f) {
                        f = g - 1
                    }
                    c = this.getAt(e).get("slot");
                    this.getAt(e).data.slot = this.getAt(f).get("slot");
                    this.getAt(f).data.slot = c;
                    return true
                },
                removeAbility: function(d, f) {
                    var c = this.getCount(),
                        e;
                    if ((c - 1) == f) {
                        this.getAt(f).data.slot = null
                    } else {
                        for (e = f; e < c - 1; e++) {
                            this.getAt(e).data.slot = this.getAt(e + 1).get("slot");
                            this.getAt(e + 1).data.slot = null
                        }
                    }
                    this.fireEvent("update", this, d, "delete", undefined)
                },
                getEnableData: function() {
                    var e, c = this.getCount(),
                        d = [],
                        f;
                    for (e = 0; e < c; e++) {
                        f = this.getAt(e).get("slot");
                        if (f == null) {
                            break
                        }
                        d.push(f)
                    }
                    return d
                },
                getEnableDataCd: function() {
                    var d = this.getEnableData(),
                        c = [];
                    Ext.Array.forEach(d, function(e) {
                        c.push(e.code)
                    });
                    return c
                },
                getFactorCount: function() {
                    var d = this.getEnableData(),
                        c = 0;
                    Ext.Array.forEach(d, function(e) {
                        if (e.factor) {
                            c++
                        }
                    });
                    return c
                }
            });
        return a
    },
    calcSuccess: function(q, o) {
        var v = this,
            l = o.get("extend"),
            b = o.get("generate"),
            s = o.get("status"),
            h = o.get("boost"),
            m = o.get("exboost"),
            r = o.get("code"),
            p = q.isMutationI(),
            n = q.isMutationII(),
            t = q.isPhotonCollect(),
            e = v.getLevel(o.get("name")),
            k = 0,
            g = 0,
            f = 0,
            d = 0,
            a = 0,
            c = function(B, x) {
                var D = 0,
                    C = 0,
                    F = 0,
                    E;
                if (v.constBoostPoint.mutation1[B] && v.constBoostPoint.mutation1[B][s]) {
                    D = p ? v.constBoostPoint.mutation1[B][s][e] : 0
                }
                if (v.constBoostPoint.mutation2[B] && v.constBoostPoint.mutation2[B][s]) {
                    C = n ? v.constBoostPoint.mutation2[B][s][e] : 0
                }
                E = v.indexOf(q.exStack, r);
                if (E) {
                    var z = 0;
                    for (var y = 0; y < q.exStack[E].length; y++) {
                        if (v.constBoostPoint[q.exStack[E][y]][B] && v.constBoostPoint[q.exStack[E][y]][B][s]) {
                            if (Ext.isObject(v.constBoostPoint[q.exStack[E][y]][B][s][e])) {
                                var A = v.constBoostPoint[q.exStack[E][y]][B][s][e]["boost"],
                                    w = v.constBoostPoint[q.exStack[E][y]][B][s][e]["max"];
                                z = (x + A) <= w ? A : Math.abs(w - x)
                            } else {
                                z = v.constBoostPoint[q.exStack[E][y]][B][s][e]
                            }
                        }
                        F = Math.max(F, z)
                    }
                }
                return Math.max(D, C, F)
            };
        if (q.refHashStack[r]) {
            k = q.refHashStack[r]
        }
        if (l && q.hashStack[r]) {
            if (o.get("require")) {
                if (q.hashStack[o.get("require")]) {
                    g = l[v.overflow(l.length, q.hashStack[r], 1)]
                }
            } else {
                g = l[v.overflow(l.length, q.hashStack[r], 1)]
            }
        }
        if (b && q.levelupHashStack[r]) {
            var u = 0;
            f = b[v.overflow(b.length, q.levelupHashStack[r], 2)] + c("create", 0);
            if (v.constBoostPoint.photon["create"] && v.constBoostPoint.photon["create"][s]) {
                u = t ? v.constBoostPoint.photon["create"][s][e] : 0
            }
            f = Math.max(f, u)
        }
        if (s) {
            if (k || g) {
                d = Math.max(k + c("extend", k), g + c("extend", g))
            }
        }
        a = Math.max(Math.max(Math.max(k, g), f), d);
        if (a && q.refBonusStack[r]) {
            a += q.refBonusStack[r]
        }
        return Math.min(100, a)
    },
    indexOf: function(a, c) {
        if (c && a) {
            if (Ext.isArray(a)) {
                for (i = 0; i < a.length; i++) {
                    if (a[i] && a[i] == c.substr(0, a[i].length)) {
                        return i
                    }
                }
            } else {
                if (Ext.isObject(a)) {
                    for (var b in a) {
                        if (b == c.substr(0, b.length)) {
                            return b
                        }
                    }
                    return null
                }
            }
        }
        return -1
    },
    overflow: function(a, c, b) {
        if (a < c) {
            return a - 1
        }
        return Math.max(0, c - b)
    },
    findAbilityName: function(c) {
        var b = this,
            a = b.getAbilityStore();
        return a.findRecord("code", c)
    },
    getLevel: function(b) {
        var a = 0;
        if (0 < b.indexOf("IV")) {
            a = 4
        } else {
            if (0 < b.indexOf("VI")) {
                a = 6
            } else {
                if (0 < b.indexOf("V")) {
                    a = 5
                } else {
                    if (0 < b.indexOf("III")) {
                        a = 3
                    } else {
                        if (0 < b.indexOf("II")) {
                            a = 2
                        } else {
                            if (0 < b.indexOf("I")) {
                                a = 1
                            }
                        }
                    }
                }
            }
        }
        return a
    },
    getSuccessList: function(b, g, a) {
        var l = this,
            n = (g.length + a.length),
            f = b.enableCheckMax == n,
            m = (2 <= b.enableMaterial()),
            o = l.getAbilityStore(),
            e = g.length,
            c, d, p, h = [];
        for (d = 0; d < e; d++) {
            var k = (g[d].inputValue.substr(0, 1) == "*");
            c = o.findRecord("code", k ? g[d].inputValue.substr(1) : g[d].inputValue);
            if (c) {
                p = k ? 100 : l.calcSuccess(b, c);
                if (f) {
                    p = parseInt((p * l.constExtra[n - 1][m]) / 100)
                }
                h.push({
                    name: c.get("name"),
                    success: p
                })
            }
        }
        e = a.length;
        for (d = 0; d < e; d++) {
            p = a[d].get("extend");
            if (f) {
                p = parseInt((p * l.constExtra[n - 1][m]) / 100)
            }
            h.push({
                name: a[d].get("name"),
                success: p
            })
        }
        return h
    },
    getSuccessList2: function(a, e) {
        var h = this,
            k = (2 <= a.enableMaterial()),
            l = h.getAbilityStore(),
            d = e.length,
            b, c, m, f = {};
        for (c = 0; c < d; c++) {
            var g = (e[c]["code"].substr(0, 1) == "*");
            b = l.findRecord("code", g ? e[c]["code"].substr(1) : e[c]["code"]);
            if (b) {
                m = g ? 100 : h.calcSuccess(a, b);
                f[b.get("code")] = m
            }
        }
        return f
    }
});
Ext.ns("PSO2");
Ext.chart.theme.Browser = Ext.extend(Ext.chart.theme.Base, {
    constructor: function(a) {
        Ext.chart.theme.Base.prototype.constructor.call(this, Ext.apply({
            colors: ["rgb(0, 0, 255)", "rgb(127, 255, 0)", "rgb(255, 215, 0)", "rgb(255, 165, 0)", "rgb(255, 69, 0)", "rgb(128, 10, 128)", "rgb(128, 0, 0)", "rgb(64, 64, 64)", "rgb(0, 0, 0)", "rgb(32, 0, 0)"]
        }, a))
    }
});
Ext.define("PSO2.ResultPanel", {
    extend: "Ext.panel.Panel",
    alias: "widget.resultpanel",
    layout: "anchor",
    baseCls: Ext.baseCSSPrefix + "panel-body-default-framed " + Ext.baseCSSPrefix + "resultpanel",
    xtype: "resultpanel",
    padding: "0",
    autoHeight: true,
    suspendCheckChange: 0,
    constViewPanel: "-viewpanel",
    constSelOption1: "-selopt-1",
    constSelOption2: "-selopt-2",
    constSelOption3: "-selopt-3",
    constChkOption1: "-chkopt-1",
    constSuccessPanel: "-successpanel",
    emptyText: "&nbsp;",
    dodoButtonText: "Dudu It",
    redodoButtonText: "Dudu It Again",
    moreButtonText: "Success or +10,000",
    moreDodoLimit: 10000,
    monimoniButtonText: "Details",
    abText: ["S-ATK", "R-ATK", "T-ATK", "S-DEF", "R-DEF", "T-DEF", "DEX", "HP", "PP", "Strike Resist", "Range Resist", "Tech Resist", "Fire Resist", "Ice Resist", "Lightning Resist", "Wind Resist", "Light Resist", "Dark Resist"],
    allUp: ["S-ATK", "R-ATK", "T-ATK", "S-DEF", "R-DEF", "T-DEF", "DEX"],
    resistAll: ["Strike Resist", "Range Resist", "Tech Resist", "Fire Resist", "Ice Resist", "Lightning Resist", "Wind Resist", "Light Resist", "Dark Resist"],
	//regParam: new RegExp("([^\\(]+)\\(([\\+\\-]\\d+)\\)"),
    optionStore1: Ext.create("Ext.data.Store", {
        fields: ["id", "name", "value", "fn"],
        data: {}
    }),
    initOption1Value: "A01",
    optionStore2: Ext.create("Ext.data.Store", {
        fields: ["id", "name", "value", "extend", "effect"],
        data: {}
    }),
    excludePattern: [],
    initOption2Value: "B01",
    optionStore3: Ext.create("Ext.data.Store", {
        fields: ["id", "name", "value", "fn"],
        data: {}
    }),
    initOption3Value: "C01",
    totalValue: 0,
    sameBonusText: "Same",
    sameBonusBoost: [1, 1.1, 1.15],
    calcSameBonus: function(a, b) {
        var c = this;
        return Math.min(parseInt(a.success * c.sameBonusBoost[PSO2.utils.overflow(c.sameBonusBoost.length, b + 1, 1)]), 100)
    },
    initComponent: function() {
        var a = this;
        a.abilitySet = Ext.create("PSO2.AbilitySet", {
            abilityComponent: a.abilityComponent,
            abilityStore: a.abilityComponent.getAbilityStore()
        });
        if (a.supportData) {
            a.optionStore1.loadData(a.supportData)
        }
        if (a.additionalData) {
            a.optionStore2.loadData(a.additionalData)
        }
        if (a.potentialData) {
            a.optionStore3.loadData(a.potentialData)
        }
        this.addEvents("opt1change", "opt2change", "opt3change", "dodochange", "successchange");
        a.callParent(arguments)
    },
    initItems: function() {
        var b = this;
        b.resultItems = [];
        b.optionItems = [];
        b.successStore = Ext.create("Ext.data.ArrayStore", {
            autoDestroy: true,
            storeId: b.id + "-store",
            idIndex: 0,
            fields: [{
                name: "name",
                type: "string"
            }, {
                name: "success",
                type: "numeric"
            }]
        });
        b.viewPanel = Ext.create("Ext.view.View", {
            autoWidth: true,
            autoHeight: true,
            store: b.successStore,
            tpl: ['<table style="width:100%">', '<tpl for=".">', '<tr id="success">', '<td style="width:50%;padding-bottom:5px">{name}</td>', '<td style="width:50%;padding-bottom:5px">{success}%</td>', "</tr>", "</tpl>", "</table>", '<div style="clear:both"></div>'],
            itemSelector: "tr#success"
        });
        b.selOpt1 = b.createComboBox(b.constSelOption1, b.optionStore1, b.initOption1Value, "opt1change");
        b.selOpt2 = b.createComboBox(b.constSelOption2, b.optionStore2, b.initOption2Value, "opt2change", function(c) {
            if (c.value == null || c.originalValue == c.value) {
                this.optionItems = []
            } else {
                this.optionItems = [this.getSelectOptionRecord(c)]
            }
        });
        b.selOpt3 = b.createComboBox(b.constSelOption3, b.optionStore3, b.initOption3Value, "opt3change");
        var a = b.id + b.constChkOption1;
        b.chkOpt1 = Ext.create("Ext.form.Checkbox", {
            id: a,
            labelWidth: 38,
            fieldLabel: b.sameBonusText,
            getSameCount: function() {
                if (!this.checked) {
                    return 0
                }
                var d = b.abilitySet,
                    c = d.stores.length,
                    f, e = 0;
                for (f = 0; f < c; f++) {
                    e += d.stores[f].exist() ? 1 : 0
                }
                return Math.max(0, e - 1)
            },
            listeners: {
                scope: b,
                change: function(e, f, c, d) {
                    this.refresh()
                }
            }
        });
        b.successPanel = Ext.create("Ext.panel.Panel", {
            id: b.id + b.constSuccessPanel,
            xtype: "panel",
            html: b.emptyText,
            style: {
                textAlign: "right"
            },
            padding: "0 0 5 0",
            anchor: "100%"
        });
        b.dodoButton = Ext.create("Ext.button.Button", {
            xtype: "button",
            text: b.dodoButtonText,
            anchor: "70%",
            disabled: true,
            scope: b,
            handler: b.onClickDoDo
        });
        b.patternButton = Ext.create("Ext.button.Button", {
            xtype: "button",
            text: b.monimoniButtonText,
            anchor: "30%",
            disabled: true,
            scope: b,
            handler: b.onClickPattern
        });
        b.items = [b.viewPanel, b.selOpt1, b.selOpt2, b.selOpt3, b.chkOpt1, b.successPanel, b.dodoButton, b.patternButton];
        b.prefixOptions = b.prefixOptions || {};
        b.prefixOptions[b.initOption1Value.charAt(0)] = b.selOpt1;
        b.prefixOptions[b.initOption2Value.charAt(0)] = b.selOpt2;
        b.prefixOptions[b.initOption3Value.charAt(0)] = b.selOpt3;
        b.callParent(arguments)
    },
    createComboBox: function(f, b, d, a, c) {
        var e = this;
        return Ext.create("Ext.form.field.ComboBox", {
            id: e.id + f,
            store: b,
            displayField: "id",
            forceSelection: true,
            editable: false,
            queryMode: "local",
            valueField: "value",
            value: d,
            typeAhead: true,
            anchor: "100%",
            disabled: true,
            listeners: {
                scope: e,
                change: function(h, g) {
                    if (Ext.isFunction(c)) {
                        c.call(this, h)
                    }
                    if (g !== true) {
                        this.refresh();
                        this.fireEvent(a, this, h, h.originalValue == h.value)
                    }
                }
            }
        })
    },
    bindStore: function(a) {
        var b = this;
        return b.abilitySet.putStore(a)
    },
    getSelectOptionRecord: function(a) {
        return a.findRecord("value", a.getValue())
    },
    selectOption: function(a) {
        var c = this,
            b = c.prefixOptions[a.charAt(0)];
        if (b) {
            b.select(a)
        }
    },
    refresh: function() {
        var g = this,
            b = g.viewPanel,
            c = g.successPanel,
            d = g.getSelectOptionRecord(g.selOpt1).get("fn"),
            a = g.getSelectOptionRecord(g.selOpt3).get("fn"),
            e = g.chkOpt1.getSameCount(),
            f, k = 100,
            m = [],
            l;
        g.successStore.loadData(m);
        g.successItems = g.abilityComponent.getSuccessList(g.abilitySet, g.resultItems, g.optionItems);
        for (f = 0; f < g.successItems.length; f++) {
            l = g.calcSameBonus(g.successItems[f], e);
            l = d(l);
            l = a(l);
            if (g.boostFunction) {
                l = g.boostFunction(l)
            }
            m.push([g.successItems[f]["name"], l]);
            k *= l
        }
        if (0 < m.length) {
            g.successStore.loadData(m)
        }
        var h = g.totalValue;
        if (g.successItems.length == 0) {
            g.totalValue = 0;
            c.update(g.emptyText)
        } else {
            g.totalValue = k / Math.pow(100, f);
            c.update(g.totalValue + "%")
        }
        g.enableDoDoButton();
        g.enableOptionsSelect();
        if (h != g.totalValue) {
            g.fireEvent("successchange", g, g.totalValue, h)
        }
    },
    isDodo: function() {
        var a = this;
        return (0 < a.abilitySet.enableMaterialMaxCount() && 1 <= a.abilityCount())
    },
    enableDoDoButton: function() {
        var c = this,
            b = c.dodoButton,
            a = c.patternButton,
            d = b.isDisabled();
        if (c.isDodo()) {
            b.enable();
            a.enable();
            if (d) {
                c.fireEvent("dodochange", c, true, false)
            }
        } else {
            b.disable();
            a.disable();
            if (!d) {
                c.fireEvent("dodochange", c, false, true)
            }
        }
    },
    abilityCount: function() {
        var a = this;
        return a.resultItems.length + a.optionItems.length
    },
    enableOptionsSelect: function() {
        var a = this;
        if (0 < a.abilityCount()) {
            a.selOpt1.enable();
            a.selOpt3.enable()
        } else {
            a.selOpt1.select(a.optionStore1.getAt(0));
            a.selOpt1.disable();
            a.selOpt3.select(a.optionStore3.getAt(0));
            a.selOpt3.disable()
        }
        if (a.resultItems.length < a.abilitySet.enableMaterialMaxCount()) {
            a.selOpt2.enable()
        } else {
            a.selOpt2.disable()
        }
    },
    removeAll: function() {
        var a = this;
        a.resultItems = [];
        a.abilitySet.resetAbility();
        a.selOpt2.select(a.optionStore2.getAt(0))
    },
    updateResults: function(b) {
        var c = this,
            a = [],
            d;
        if (!b.rendered) {
            return false
        }
        b.removeAll(true);
        c.removeAll();
        c.abilitySet.forEach(function(f, e) {
            if (e !== true) {
                a.push(f)
            }
        }, c);
        d = c.abilityComponent.getSuccessList2(c.abilitySet, a);
        c.abilitySet.forEach(function(f, e) {
            if (e) {
                b.add({
                    fieldStyle: "float:left",
                    boxLabel: '<p class="x-factor-icon" style="float:left;margin-left:2px;padding-left:16px">' + f.name + '</p><p style="float:right;padding-right:3px">100%</p>',
                    inputValue: "*" + f.code,
                    abilityData: f,
                    resultPanel: c,
                    fieldSet: b
                })
            } else {
                if (d[f.code]) {
                    b.add({
                        fieldStyle: "float:left",
                        boxLabel: '<p style="float:left;padding-left:3px">' + f.name + '</p><p style="float:right;padding-right:3px">' + d[f.code] + "%</p>",
                        inputValue: f.code,
                        abilityData: f,
                        resultPanel: c,
                        fieldSet: b
                    })
                }
            }
        }, c);
        c.refresh()
    },
    getEnableMaxCount: function() {
        return this.abilitySet.enableMaterialMaxCount()
    },
    getValues: function() {
        var b = this,
            a = [];
        Ext.Array.forEach(b.resultItems, function(c) {
            a.push(c.inputValue)
        });
        return a
    },
    isExcludePattern: function(q, p) {
        var m = this,
            l = Ext.isArray(m.excludePattern) ? m.excludePattern : [m.excludePattern];
        var g = l.length,
            d = q.substr(0, 1) == "*",
            b = p.substr(0, 1) == "*",
            h = d ? q.substr(1, 2) : q.substr(0, 2),
            f = b ? p.substr(1, 2) : p.substr(0, 2),
            r = /([^\*]+)\*$/,
            a, o = function(s, t) {
                if (a = s.match(r)) {
                    return s.substr(0, a[1].length) == t.substr(0, a[1].length)
                }
                return s == t
            };
        if (h == f) {
            return true
        }
        for (var e = 0; e < g; e++) {
            var n = l[e],
                k = false,
                c;
            n = Ext.isArray(n) ? n : [n];
            for (c = 0; c < n.length; c++) {
                k = o(n[c], h);
                if (k) {
                    break
                }
            }
            if (k) {
                for (c = 0; c < n.length; c++) {
                    if (o(n[c], f)) {
                        return true
                    }
                }
            }
        }
        return false
    },
    addAbility: function(f, c) {
        var e = this,
            b = [],
            a = e.resultItems.length,
            d;
        for (d = 0; d < a; d++) {
            if (e.isExcludePattern(f.inputValue, e.resultItems[d].inputValue)) {
                b.push(e.resultItems[d])
            }
        }
        for (d = 0; d < b.length; d++) {
            b[d].setValue(false)
        }
        e.resultItems.push(f);
        if (c !== true) {
            e.refresh()
        }
        return e.abilityCount()
    },
    removeAbility: function(d, a) {
        var c = this,
            b = Ext.Array.indexOf(c.resultItems, d);
        if (0 <= b) {
            c.resultItems.splice(b, 1);
            if (a !== true) {
                c.refresh()
            }
        }
        return c.abilityCount()
    },
    doDo: function(k, d) {
        var h = this,
            b = h.getSelectOptionRecord(h.selOpt1).get("fn"),
            a = h.getSelectOptionRecord(h.selOpt3).get("fn"),
            c = h.chkOpt1.getSameCount(),
            g = h.successItems,
            f = g.length,
            e, l;
        if (0 < f) {
            for (e = 0; e < f; e++) {
                l = h.calcSameBonus(g[e], c);
                l = b(l);
                l = a(l);
                if (h.boostFunction) {
                    l = h.boostFunction(l)
                }
                if (100 <= l || Math.floor(Math.random() * 100) < l) {
                    k.push({
                        fieldLabel: g[e].name,
                        name: (h.id + "-" + e),
                        value: l + "%"
                    })
                } else {
                    d.push({
                        fieldLabel: g[e].name,
                        name: (h.id + "-" + e),
                        value: l + "%"
                    })
                }
            }
        }
        return (0 < k.length) && (d.length == 0)
    },
    getTotalSuccess: function(b, c) {
        var a = "Total: " + b + " / " + (b + c) + " = ";
        if (b == 0) {
            a += "0%"
        } else {
            a += Ext.util.Format.number((b / (b + c)) * 100, "0.000") + "%"
        }
        return a
    },
    selectedOptions: function() {
        var a = this;
        return [a.selOpt1.value, a.selOpt2.value, a.selOpt3.value]
    },
    onClickDoDo: function() {
        var c = this;
        if (0 < c.items.length) {
            var d = [],
                a = [],
                b = c.doDo(d, a);
            c.win = Ext.create("widget.window", {
                title: "Synthesis Results",
                autoDestroy: true,
                closable: true,
                closeAction: "destroy",
                width: c.noDD === true ? Ext.getBody().getWidth() : Math.min(Ext.getBody().getWidth(), 600),
                height: 148 + (d.length + a.length) * 26,
                modal: true,
                successNum: b ? 1 : 0,
                failNum: b ? 0 : 1,
                layout: "anchor",
                bodyStyle: "padding: 5px;",
                defaults: {
                    anchor: "100%"
                },
                items: [{
                    xtype: "fieldset",
                    frame: true,
                    title: "Addition Successful",
                    margins: "0 5 0 5",
                    layout: "anchor",
                    autoHeight: true,
                    defaultType: "textfield",
                    defaults: {
                        readOnly: true,
                        labelWidth: c.noDD === true ? (Ext.getBody().getWidth() / 2) : 140,
                        anchor: "100%"
                    },
                    items: d
                }, {
                    xtype: "fieldset",
                    frame: true,
                    title: "Addition Failed",
                    margins: "0 5 0 5",
                    layout: "anchor",
                    autoHeight: true,
                    defaultType: "textfield",
                    defaults: {
                        readOnly: true,
                        labelWidth: c.noDD === true ? (Ext.getBody().getWidth() / 2) : 140,
                        anchor: "100%"
                    },
                    items: a
                }],
                dockedItems: [{
                    xtype: "toolbar",
                    ui: "footer",
                    dock: "bottom",
                    items: [{
                        xtype: "label",
                        readOnly: true,
                        textAlign: "right",
                        html: c.getTotalSuccess(b ? 1 : 0, b ? 0 : 1),
                        bodyStyle: {
                            "float": "hidden"
                        }
                    }, "->", Ext.create("Ext.button.Button", {
                        text: c.redodoButtonText,
                        scope: c,
                        handler: function() {
                            var g = [],
                                f = [],
                                e = this.win.query("fieldset"),
                                h = this.win.query("toolbar")[0].query("label");
                            if (this.doDo(g, f)) {
                                this.win.successNum++
                            } else {
                                this.win.failNum++
                            }
                            e[0].removeAll();
                            e[0].add(g);
                            e[1].removeAll();
                            e[1].add(f);
                            h[0].update(this.getTotalSuccess(this.win.successNum, this.win.failNum))
                        },
                        minWidth: 64
                    }), Ext.create("Ext.button.Button", {
                        text: c.moreButtonText,
                        scope: c,
                        handler: function() {
                            var h = [],
                                f = [],
                                e = this.win.query("fieldset"),
                                k = this.win.query("toolbar")[0].query("label"),
                                g = this.moreDodoLimit;
                            while (!this.doDo(h, f) && g--) {
                                this.win.failNum++;
                                h = [];
                                f = []
                            }
                            if (f.length == 0) {
                                this.win.successNum++
                            }
                            e[0].removeAll();
                            e[0].add(h);
                            e[1].removeAll();
                            e[1].add(f);
                            k[0].update(this.getTotalSuccess(this.win.successNum, this.win.failNum))
                        },
                        minWidth: 64
                    }), Ext.create("Ext.button.Button", {
                        text: "Close",
                        scope: c,
                        handler: function() {
                            if (this.win) {
                                this.win.close()
                            }
                            delete this.win;
                            this.win = null
                        },
                        minWidth: 64
                    })]
                }]
            }).show()
        }
    },
    popCnt: function(b) {
        b >>>= 0;
        for (var a = 0; b; b &= b - 1) {
            a++
        }
        return a
    },
    probability: function(d) {
        var a = d.length,
            b = 1;
        for (var c = 0; c < a; c++) {
            b *= d[c]
        }
        return b / Math.pow(100, a)
    },
    addition: function(d) {
        var a = d.length,
            c = 0;
        for (var b = 0; b < a; b++) {
            c += d[b]
        }
        return c
    },
    getSuccessPattern: function(b, g, k) {
        var h = this,
            e = g.length,
            a = 1 << e,
            f = [],
            d, c;
        for (d = 0; d < a; d++) {
            if (b == h.popCnt(d)) {
                var l = [];
                for (c = 0; c < e; c++) {
                    if (d & (1 << c)) {
                        l.push(100 - k(g[c]))
                    } else {
                        l.push(k(g[c]))
                    }
                }
                f.push(h.probability(l))
            }
        }
        return h.addition(f)
    },
    addAbilityParameter: function(e, a, d) {
        var c = this;
        if (a == "ALL") {
            for (var b = 0; b < c.allUp.length; b++) {
                c.addAbilityParameter(e, c.allUp[b], d)
            }
        } else {
            if (a == "All Resist") {
                for (var b = 0; b < c.resistAll.length; b++) {
                    c.addAbilityParameter(e, c.resistAll[b], d)
                }
            } else {
                if (!e[a]) {
                    e[a] = 0
                }
                e[a] += d
            }
        }
    },
    onClickPattern: function() {
        var d = this;
        if (0 < d.items.length) {
            var c = d.successItems,
                e = [],
                b = [],
                a = [];
            e.push(d.getSpecInfo(c));
            e.push(d.getSuccessTable(c, b, a));
            e.push(d.getSuccessGraph(c, b, a));
            e.push(d.getOrderView(c));
            d.win = Ext.create("widget.window", {
                title: "Data Monitor",
                autoDestroy: true,
                closable: true,
                closeAction: "destroy",
                width: d.noDD === true ? Ext.getBody().getWidth() : 600,
                autoHeight: true,
                modal: true,
                layout: "fit",
                bodyStyle: "padding: 5px;",
                items: Ext.createWidget("tabpanel", {
                    activeTab: 0,
                    defaults: {
                        bodyPadding: 5
                    },
                    items: e
                }),
                dockedItems: [{
                    xtype: "toolbar",
                    ui: "footer",
                    dock: "bottom",
                    items: ["->", Ext.create("Ext.button.Button", {
                        text: "Close",
                        scope: d,
                        handler: function() {
                            if (this.win) {
                                this.win.close()
                            }
                            delete this.win;
                            this.win = null
                        },
                        minWidth: 105
                    })]
                }]
            }).show()
        }
    },
    getSpecInfo: function(l) {
        var m = this,
            b = m.abilitySet.abilityStore,
            o, d, h, a = {},
            k = [],
            n = new RegExp("([^\\(]+)\\(([\\+\\-]\\d+)\\)"),
            g = l.length,
            f = "",
            c;
        for (c = 0; c < g; c++) {
            o = b.findRecord("name", l[c].name) || m.optionStore2.findRecord("name", l[c].name);
            d = o.get("effect").replace(/<br>/g, ",").split(",");
            for (j = 0; j < d.length; j++) {
                h = d[j].match(n);
                if (h && h.length == 3) {
                    m.addAbilityParameter(a, h[1], parseInt(h[2]))
                } else {
                    if (h === null) {
                        k.push(d[j])
                    }
                }
            }
        }
        for (c = 0; c < m.abText.length; c++) {
            if (a[m.abText[c]]) {
                if (0 < a[m.abText[c]]) {
                    f += "<div>" + m.abText[c] + '<span style="color:red;font-weight:bold">&nbsp;&nbsp;(+' + Math.abs(a[m.abText[c]]) + ")</span></div>"
                } else {
                    f += "<div>" + m.abText[c] + '<span style="color:blue;font-weight:bold">&nbsp;&nbsp;(-' + Math.abs(a[m.abText[c]]) + ")</span></div>"
                }
            }
        }
        for (c = 0; c < k.length; c++) {
            f += "<div>" + k[c] + "</div>"
        }
        return {
            title: "Abilities",
            html: f
        }
    },
    getSuccessTable: function(h, o, f) {
        var k = this,
            n = [],
            l = k.getSelectOptionRecord(k.selOpt3).get("fn"),
            g = h.length,
            b = k.selOpt1.store,
            c = b.count(),
            q, d;
        for (d = 0; d < g; d++) {
            q = k.calcSameBonus(h[d], k.chkOpt1.getSameCount());
            q = l(q);
            if (k.boostFunction) {
                q = k.boostFunction(q)
            }
            n.push(q)
        }
        var e = '<table id="ps"><tr><td id="psh"></td>';
        for (d = 0; d < c; d++) {
            rec = b.getAt(d);
            e += '<td id="psh" style="width:' + parseInt(88 / c) + '%">' + rec.get("name") + "</td>"
        }
        e += "</tr>";
        var m;
        for (d = 0; d <= g; d++) {
            if (d == 0) {
                m = "Success"
            } else {
                if (d == g) {
                    m = "Complete Failure"
                } else {
                    m = d + "Failure(s)"
                }
            }
            e += '<tr><td id="ps">' + m + "</td>";
            f.push(m);
            for (j = 0; j < c; j++) {
                var a = k.getSuccessPattern(d, n, b.getAt(j).get("fn"));
                e += "<td";
                if (a == 1) {
                    e += ' id="bold"'
                } else {
                    if (0.8 < a) {
                        e += ' id="high"'
                    } else {
                        if (a < 0.1) {
                            e += ' id="low"'
                        }
                    }
                }
                e += ">" + Ext.util.Format.number(a * 100, "0.000") + "%</td>";
                o[j] = o[j] || {};
                if (d == 0) {
                    o[j]["name"] = b.getAt(j).get("name")
                }
                o[j][m] = a * 100
            }
            e += "</tr>"
        }
        e += "</table>";
        return {
            title: "Success Rate Pattern",
            html: e
        }
    },
    getSuccessGraph: function(d, c, b) {
        var a = d.length;
        return {
            xtype: "chart",
            title: "Success Rate Graph",
            height: 160 + 24 * a,
            style: "background:#fff",
            animate: true,
            theme: "Browser:gradients",
            defaultInsets: 30,
            store: Ext.create("Ext.data.JsonStore", {
                fields: b,
                data: c
            }),
            legend: {
                position: "right"
            },
            axes: [{
                type: "Numeric",
                position: "left",
                fields: b,
                title: "Lost %",
                grid: true,
                decimals: 0,
                minimum: 0,
                maximum: 100
            }, {
                type: "Category",
                position: "bottom",
                fields: ["name"],
                title: "Usage"
            }],
            series: [{
                type: "area",
                axis: "left",
                highlight: true,
                tips: {
                    trackMouse: true,
                    width: 170,
                    height: 28,
                    renderer: function(f, e) {
                        this.setTitle(e.storeField + " - " + Ext.util.Format.number(f.get(e.storeField), "0.000") + "%")
                    }
                },
                xField: "name",
                yField: b,
                style: {
                    lineWidth: 1,
                    stroke: "#666",
                    opacity: 0.86
                }
            }]
        }
    },
    getOrderView: function(d) {
        var f = this,
            c = d.length,
            b = [],
            a, e;
        for (e = 0; e < c; e++) {
            b.push({
                html: d[e]["name"]
            })
        }
        a = Ext.create("Ext.form.FieldSet", {
            frame: true,
            title: "Special Abilities",
            margins: "0",
            width: "100%",
            layout: "column",
            autoHeight: true,
            defaults: {
                columnWidth: 0.5,
                border: 0,
                margin: "5 0 10 0",
                cls: "x-order-ability"
            },
            viewLimit: -1,
            viewAbility: false,
            stackAbility: [],
            capacityOver: false,
            items: b,
            getCount: function() {
                return this.items.length + this.stackAbility.length
            }
        });
        return {
            xtype: "panel",
            title: "Order",
            layout: "column",
            items: [{
                xtype: "checkbox",
                boxLabel: "Potential/Timed Ability",
                fs: a,
                listeners: {
                    scope: f,
                    change: function(k, h, g, l) {
                        a.viewAbility = h;
                        f.updateOrderView(a, h != g)
                    }
                }
            }, Ext.create("Ext.form.field.ComboBox", {
                fs: a,
                style: "marginLeft: 15px",
                store: Ext.create("Ext.data.ArrayStore", {
                    autoDestroy: true,
                    fields: [{
                        name: "id",
                        type: "numeric"
                    }, {
                        name: "name",
                        type: "string"
                    }],
                    data: [
                        [-1, "Default"],
                        [6, "6 Slots"],
                        [8, "8 Slots"]
                    ]
                }),
                displayField: "name",
                forceSelection: true,
                editable: false,
                queryMode: "local",
                valueField: "id",
                value: a.viewLimit,
                typeAhead: true,
                anchor: "100%",
                listeners: {
                    scope: f,
                    change: function(k, h, g, l) {
                        a.viewLimit = h;
                        f.updateOrderView(a, false)
                    }
                }
            }), a]
        }
    },
    updateOrderView: function(c, e) {
        var b = c.getCount();
        if (e) {
            if (c.viewAbility) {
                c.insert(0, {
                    html: "Potential/Timed Ability",
                    cls: "x-order-with-ability"
                })
            } else {
                c.remove(c.items.getAt(0))
            }
        }
        if (c.capacityOver) {
            c.remove(c.items.getAt(c.items.length - 1));
            for (; 0 < c.stackAbility.length;) {
                c.add(c.stackAbility.pop())
            }
        }
        if (c.viewLimit != -1) {
            if (c.viewLimit < c.getCount()) {
                for (; c.viewLimit <= c.items.length;) {
                    var d = c.items.getAt(c.items.length - 1);
                    c.stackAbility.push({
                        html: d.el.dom.textContent
                    });
                    c.remove(d)
                }
            } else {
                for (; c.items.length <= c.viewLimit && 0 < c.stackAbility.length;) {
                    c.add(c.stackAbility.pop())
                }
            }
        }
        if (0 < c.stackAbility.length) {
            c.add({
                html: "and " + c.stackAbility.length + " others"
            });
            c.capacityOver = true
        } else {
            c.capacityOver = false
        }
    }
});
Ext.ns("PSO2");
Ext.override(Ext.data.Record, {
    isModified: function(a) {
        return false
    }
});
Ext.override(Ext.grid.header.Container, {
    sortAscText: "Ascending",
    sortDescText: "Descending",
    sortClearText: "Clear",
    columnsText: "Columns"
});
Ext.override(Ext.tab.Tab, {
    closeText: "Close Tab"
});
Ext.define("PSO2.TabCloseMenu", {
    extend: "Ext.tab.TabCloseMenu",
    closeTabText: "Close this tab",
    closeText: "Close this tab",
    closeOthersTabsText: "Close other tabs",
    closeAllTabsText: "Close all tabs",
    onAfterLayout: function() {
        var a = {
            scope: this,
            delegate: "div.x-tab"
        };
        a[this.menuTrigger] = function(c, d) {
            var b = this;
            if (b.tabBar.getChildByElement(d)) {
                b.onContextMenu(c, d)
            }
        };
        this.mon(this.tabBar.el, a)
    }
});
Ext.define("PSO2.GridGrouping", {
    extend: "Ext.grid.feature.Grouping",
    enableGroupingMenu: false,
    startCollapsed: true,
    groupHeaderTpl: "{[this.getHeaderName(values)]}",
    getFragmentTpl: function() {
        return Ext.apply(this.callParent(arguments) || {}, {
            getHeaderName: this.getHeaderName
        })
    },
    getHeaderName: function(a) {
        if (a.name == "A") {
            return "Stat Enhancement"
        } else {
            if (a.name == "A+") {
                return "Stat Enhancement (Special)"
            } else {
                if (a.name == "A++") {
                    return "Special Ability Factor"
                } else {
                    if (a.name == "B") {
                        return "Resistance"
                    } else {
                        if (a.name == "C") {
                            return "Status Effect"
                        } else {
                            if (a.name == "D") {
                                return "Soul"
                            } else {
                                if (a.name == "D+") {
                                    return "Fever"
                                } else {
                                    if (a.name == "E") {
                                        return "Special"
                                    } else {
                                        if (a.name == "L") {
                                            return "Super Special Abilities"
                                        }else {
										   if (a.name == "LOSS") {
											   return "Stat Enhancement (Lesser)"
											}
                                        }
                                    }
                                }
							}
                        }
                    }
                }
            }
        }
        return "Other"
    }
});
Ext.define("PSO2.SynthesisComponent", {
    extend: "Ext.container.Container",
    version: "1.79E",
    title: "PSO2 Affix Simulator",
    constCookieName: "pso2dodo",
    outputViewport: false,
    limitUrlSize: 10,
    maxMaterial: 5,
    currentTabItem: null,
    selectedGridCell: null,
    boostCampaign: true,
    getRecommendRecipe: false,
    factorMenuText: {
        on: "Add Factor",
        off: "Cancel Factor"
    },
    constructor: function(b) {
        var e = this,
            a, f = {};
        Ext.apply(e, b);
        if (e.ajaxData) {
            if (e.ajaxData.abilityList) {
                f.constAbility = e.ajaxData.abilityList
            }
            if (e.ajaxData.extraSlot) {
                f.constExtra = e.ajaxData.extraSlot
            }
            if (e.ajaxData.boostPoint) {
                f.constBoostPoint = e.ajaxData.boostPoint
            }
            if (e.ajaxData.extendAbility) {
                f.constExtendAbility = e.ajaxData.extendAbility
            }
        }
        e.ability = Ext.create("PSO2.AbilityComponent", f);
        if (e.items) {
            if (!Ext.isArray(e.items)) {
                a = [e.items]
            } else {
                a = e.items
            }
            delete e.items
        } else {
            a = []
        }
        a.push({
            cls: "app-header",
            region: "north",
            height: 35,
            layout: "fit",
            hidden: e.noDD,
            html: ['<div class="x-top-title">', e.title + " ver " + e.version + "&nbsp;", '<span class="x-top-author">', '<a href="http://rxio.blog.fc2.com/" style="text-decoration:none">Created by Pulsar@</a>&nbsp;&amp;&nbsp;', '<a target="_blank" href="http://pso2numao.web.fc2.com/dodo/" style="text-decoration:none">@ship8</a>',' | <a href="http://arks-layer.com/" style="text-decoration:none">English version maintained by Aida</a> (Updated 6-7-18)<br>Message Aida Enna#0001 on Discord or <a href="http://discord.gg/PSO2" style="text-decoration:none">join our Discord server</a> to report bugs/issues/suggestions.', "</span>", "</div>"].join("")
        });
        e.panelNames = ["Fodder"];
        for (var d = 1; d <= e.maxMaterial; d++) {
            e.panelNames.push("Fodder " + d)
        }
        if (e.noDD !== true) {
            e.abilityGrid = Ext.create("Ext.grid.Panel", {
                title: "Special Ability",
                region: "west",
                collapsible: true,
                floatable: true,
                split: true,
                forceFit: true,
                sortableColumns: false,
                scroll: false,
                columns: [{
                    dataIndex: "name",
                    header: "Ability",
                    width: 108,
                    filterable: true,
                    filter: {
                        type: "string"
                    }
                }, {
                    dataIndex: "effect",
                    header: "Effect",
                    width: 144,
                    filter: {
                        type: "string"
                    },
                    renderer: function(h, k, g) {
                        if (g.get("extup")) {
                            var l = [];
                            Ext.Array.forEach(g.get("extup"), function(m) {
                                var n = this.ability.findAbilityName(m.length == 2 ? m + "01" : m);
                                if (n) {
                                    l.push(m.length == 2 ? n.get("name").replace(/[IV]+$/, "").replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "") : n.get("name"))
                                }
                            }, e);
                            k.tdAttr = 'data-qtip="' + l.join(", ") + ' Affix Bonus"'
                        }
                        return h
                    }
                }],
                features: [{
                    ftype: "filters",
                    encode: false,
                    local: true,
                    menuFilterText: "Search",
                    filters: [{
                        type: "string",
                        dataIndex: "name"
                    }, {
                        type: "string",
                        dataIndex: "effect"
                    }]
                }, Ext.create("PSO2.GridGrouping")],
                viewConfig: {
                    altRowCls: "x-grid-row-group",
                    style: {
                        overflow: "auto",
                        overflowX: "hidden"
                    },
                    listeners: {
                        render: e.initializeAbilityDragZone
                    },
                    doStripeRows: function(k, h) {
                        if (this.stripeRows) {
                            var m = this.getNodes(k, h),
                                p = m.length,
                                l = 0,
                                o, n, g = "";
                            for (; l < p; l++) {
                                o = m[l];
                                n = this.getRecord(o);
                                o.className = o.className.replace(this.rowClsRe, " ");
                                if (n.get("code").substring(0, 2) !== g) {
                                    k++;
                                    g = n.get("code").substring(0, 2)
                                }
                                if (k % 2 === 0) {
                                    o.className += (" " + this.altRowCls)
                                }
                                if (n.get("cls")) {
                                    o.className += (" " + n.get("cls"))
                                }
                            }
                        }
                    }
                },
                store: e.ability.getAbilityStore()
            });
            a.push(e.abilityGrid)
        } else {
            e.abilityWindow = Ext.create("widget.window", {
                title: "Special Ability",
                autoDestroy: false,
                closable: true,
                closeAction: "hide",
                modal: true,
                bodyStyle: "padding:5px;",
                autoScroll: true,
                items: Ext.create("Ext.grid.Panel", {
                    store: e.ability.getAbilityStore(),
                    forceFit: true,
                    scroll: false,
                    columns: [{
                        dataIndex: "name",
                        header: "Ability",
                        filter: {
                            type: "string"
                        }
                    }, {
                        dataIndex: "effect",
                        header: "Effect",
                        filter: {
                            type: "string"
                        }
                    }],
                    viewConfig: {
                        style: {
                            overflow: "auto",
                            overflowX: "hidden"
                        },
                        listeners: {
                            scope: e,
                            cellclick: function(k, g, l, h, n, o, m) {
                                if (this.selectedGridCell) {
                                    this.selectedGridCell.view.getStore().addAbility(h.data)
                                }
                                this.selectedGridCell = null;
                                this.abilityWindow.hide()
                            }
                        }
                    }
                })
            })
        }
        e.tabPanel = Ext.createWidget("tabpanel", {
            resizeTabs: true,
            enableTabScroll: true,
            defaults: {
                autoScroll: true,
                bodyPadding: 1
            },
            plugins: Ext.create("PSO2.TabCloseMenu", {
                menuTrigger: (e.noDD ? "click" : "contextmenu"),
                extraItemsTail: ["-", {
                    text: "Fill with trash",
                    scope: e,
                    handler: function() {
                        var g = this.tabPanel.plugins[0],
                            h = this.findLocationHashBy(g.item);
                        if (0 <= h) {
                            this.tabPanel.items.getAt(h).fillDuster()
                        }
                    }
                }, {
                    text: "Copy",
                    scope: e,
                    handler: function() {
                        var g = this.tabPanel.plugins[0],
                            h = this.findLocationHashBy(g.item);
                        if (0 <= h) {
                            this.selectLoadData(null, this.locationHash[h])
                        }
                    }
                }],
                listeners: {
                    scope: e,
                    aftermenu: function() {
                        this.currentTabItem = null
                    }
                }
            }),
            listeners: {
                scope: e,
                beforeremove: function(h, g) {
                    if (g.$className != "PSO2.CostPanel") {
                        this.removeLocationHash(g)
                    }
                }
            }
        });
        var c = [Ext.create("Ext.Action", {
            iconCls: "x-add-icon",
            text: "Add Panel",
            scope: e,
            handler: function() {
                this.tabPanel.setActiveTab(this.addTab())
            }
        }), Ext.create("Ext.Action", {
            iconCls: "x-save-icon",
            text: "Save",
            scope: e,
            handler: e.saveData
        }), Ext.create("Ext.Action", {
            iconCls: "x-load-icon",
            text: "Load",
            scope: e,
            handler: e.loadData
        })];
        if (e.noDD !== true) {
            c.push(Ext.create("Ext.button.Button", {
                iconCls: "x-cost-icon",
                text: "Calculate Cost",
                pressed: false,
                enableToggle: false,
                scope: e,
                handler: function(g) {
                    if (!this.costPanel) {
                        this.costPanel = Ext.create("PSO2.CostPanel", {
                            title: "Cost Calculation",
                            autoDestroy: true,
                            noDD: this.noDD,
                            tabPanel: this.tabPanel,
                            maxMaterial: this.maxMaterial,
                            supportData: this.ajaxData.optionList.support,
                            additionalData: this.ajaxData.optionList.additional
                        });
                        this.tabPanel.insert(0, this.costPanel);
                        this.tabPanel.setActiveTab(0)
                    } else {
                        this.tabPanel.setActiveTab(this.costPanel)
                    }
                }
            }))
        }
        if (e.boostCampaign == true) {
            c.push("-");
            c.push(Ext.create("Ext.form.field.ComboBox", {
                store: Ext.create("Ext.data.JsonStore", {
                    autoLoad: false,
                    fields: ["T", "V", "F"],
                    data: [{
                        T: "No Boost",
                        V: 0,
                        F: null
                    }, {
                        T: "5% UP",
                        V: 5,
                        F: function(g) {
                            return Math.min(g + 5, 100)
                        }
                    }, {
                        T: "10% UP",
                        V: 10,
                        F: function(g) {
                            return Math.min(g + 10, 100)
                        }
                    }]
                }),
                displayField: "T",
                forceSelection: true,
                editable: false,
                queryMode: "local",
                valueField: "V",
                value: 0,
                typeAhead: true,
                width: 84,
                listeners: {
                    scope: e,
                    change: function(l, m, h) {
                        var g = this.tabPanel.query("resultpanel"),
                            k;
                        this.enableBoost = (0 < m);
                        this.boostFunction = l.store.findRecord("V", m).get("F");
                        if (this.enableBoost) {
                            l.addCls("x-campaign-up")
                        } else {
                            l.removeCls("x-campaign-up")
                        }
                        if (Ext.isArray(g)) {
                            for (k = 0; k < g.length; k++) {
                                g[k].boostFunction = this.boostFunction;
                                if (g[k].rendered) {
                                    g[k].refresh()
                                }
                            }
                        }
                    }
                }
            }))
        }
        if (e.noDD !== true && Ext.isFunction(e.getRecommendRecipe)) {
            c.push("-");
            c.push({
                iconCls: "x-recommend-menu-icon",
                style: {
                    overflow: "visible"
                },
                text: "()",
                menu: e.getRecommendRecipe()
            })
        }
        if (e.noDD !== true) {
            c.push("-");
            c.push({
                iconCls: "x-share-icon",
				text: " Changelog",
                handler: function() {
                    var g = location,
                        h = g.protocol + "//" + g.host + g.pathname + "#!" + lzbase62.compress(g.hash.substring(3));
                    Ext.create("widget.window", {
                        title: "Share/Changelog",
                        modal: true,
                        width: e.noDD === true ? Ext.getBody().getWidth() : 700,
                        height: 500,
                        layout: "fit",
                        autoDestroy: true,
                        closable: true,
                        items: [{
                            xtype: "panel",
                            anchor: "100%",
                            style: {
                                padding: "5px"
                            },
                            height: 32,
                            html: 'Your long link is: <A HREF="' + h + '">' + h + '</a><br><A HREF="http://api.bit.ly/v3/shorten?login=aidaenna&format=txt&apiKey=R_939fc6c1e5a540f9aa4e710bc4512154&longUrl=' + h.replace("#!","%23%21") + '">You can share a short version of this URL by clicking here.</A><br>Copy the URL it provides in the new window.<br>You can share via Twitter here: <a href="https://twitter.com/share" class="twitter-share-button" data-url="' + h + '" data-text="PSO2 Affix Simulation"></a><br><center><b><u>Changelog</b></u></center><br><b>4/12/2018:</b><br>- Added Loser Reverie<br><br><b>4/5/2018:</b><br>- Added the changelog<br>- Added shortlinking via bitly (can\'t do it in the javascript because fuck you java)<br>- Fixed errors with Historia/Fabula tooltips<br>- Fixed Offensive/Defensive Boost stats not showing correctly<br>- Fixed Mark Angar, Sim, and Couragena issues<br><br><b>6/7/2018:</b><br>- Added Lesser/EV<br>- Added new SSAs<br>- Fixed some bugs',
							//html: '<a href="https://twitter.com/share" class="twitter-share-button" data-url="' + h + '" data-text="PSO2 Skill Simulation"></a>',
                            listeners: {
                                single: true,
                                afterrender: function() {
                                    if (Ext.query("#twitter-wjs").length) {
                                        Ext.query("#twitter-wjs")[0].remove()
                                    }! function(o, k, q) {
                                        var n, l = o.getElementsByTagName(k)[0],
                                            m = /^http:/.test(o.location) ? "http" : "https";
                                        if (!o.getElementById(q)) {
                                            n = o.createElement(k);
                                            n.id = q;
                                            n.src = m + "://platform.twitter.com/widgets.js";
                                            l.parentNode.insertBefore(n, l)
                                        }
                                    }(document, "script", "twitter-wjs")
                                }
                            }
                        }, /*{
                            xtype: "textarea",
                            anchor: "100%",
                            layout: "fit",
                            value: h,
                            style: {
                                margin: "5px"
                            }
                        }*/],
                        dockedItems: [{
                            xtype: "toolbar",
                            ui: "footer",
                            dock: "bottom",
                            layout: {
                                pack: "center"
                            },
                            items: Ext.create("Ext.button.Button", {
                                text: "Close",
                                scope: e,
                                handler: function() {
                                    Ext.WindowMgr.getActive().close()
                                },
                                minWidth: 105
                            })
                        }]
                    }).show()
                }
            })
        }
        e.mainPanel = Ext.create("Ext.panel.Panel", {
            region: "center",
            layout: "fit",
            items: e.tabPanel,
            dockedItems: {
                xtype: "toolbar",
                items: c
            },
            listeners: {
                scope: e,
                afterrender: e.onChangeLocationHash
            }
        });
        a.push(e.mainPanel);
        Ext.create("Ext.Viewport", {
            renderTo: e.outputViewport ? Ext.get(e.outputViewport) : Ext.getBody(),
            layout: "border",
            items: a
        });
        e.initGridMenuButton();
        window.onhashchange = function() {
            e.onChangeLocationHash()
        }
    },
    initGridMenuButton: function() {
        var c = this,
            a = [],
            b;
        a.push({
            iconCls: "x-factor-icon",
            text: c.factorMenuText.on,
            scope: c,
            handler: function(d, h) {
                var f = this.selectedGridCell;
                if (f) {
                    var g = f.record.get("slot");
                    if (d.text === this.factorMenuText.on) {
                        f.view.store.each(function(l, e) {
                            var k = l.get("slot");
                            if (k != null && k.factor === true) {
                                l.set("slot", this.makeFactor(k, false));
                                return false
                            }
                            return true
                        }, this);
                        f.record.set("slot", this.makeFactor(g, true))
                    } else {
                        f.record.set("slot", this.makeFactor(g, false))
                    }
                }
                this.selectedGridCell = null
            }
        });
        for (b = 0; b < c.maxMaterial; b++) {
            a.push({
                iconCls: "x-copy-icon",
                text: "",
                scope: c,
                btnIndex: b,
                handler: c.onCopyAbility
            })
        }
        a.push({
            iconCls: "x-del-icon",
            text: "Delete",
            scope: c,
            handler: function() {
                var d = this.selectedGridCell;
                if (d) {
                    d.view.getStore().removeAbility(d.record, d.rowIndex);
                    d.view.refresh()
                }
                this.selectedGridCell = null
            }
        });
        c.gridMenu = Ext.create("Ext.menu.Menu", {
            items: a
        })
    },
    urlHashValidate: function(e) {
        var d = this,
            b = d.hasharray(e),
            a = b.length,
            c;
        if (!e.s && e.s !== "") {
            return false
        }
        for (c = 1; c < d.maxMaterial; c++) {
            if (!e[c] && e[c] !== "") {
                return false
            }
        }
        for (c = 0; c < a; c++) {
            if (b[c]) {
                if (!d.ability.isExistAbilities(b[c].split("."))) {
                    return false
                }
            }
        }
        return true
    },
    addTab: function(d) {
        var l = this,
            k = [{
                xtype: "panel",
                frame: true,
                items: {
                    xtype: "fieldset",
                    layout: "anchor",
                    title: "Select Abilities",
                    autoHeight: true,
                    padding: "0 0 0 4",
                    margin: "0 0 0 0",
                    defaults: {
                        xtype: "checkbox",
                        anchor: "100%",
                        hideEmptyLabel: true,
                        scope: l,
                        handler: l.onCheckAbility
                    }
                }
            }],
            a = {};
        if (l.ajaxData) {
            if (l.ajaxData.optionList && l.ajaxData.optionList.support) {
                a.supportData = l.ajaxData.optionList.support
            }
            if (l.ajaxData.optionList && l.ajaxData.optionList.additional) {
                a.additionalData = l.ajaxData.optionList.additional
            }
            if (l.ajaxData.optionList && l.ajaxData.optionList.additional) {
                a.potentialData = l.ajaxData.optionList.potential
            }
            if (l.ajaxData.sameBonusBoost) {
                a.sameBonusBoost = l.ajaxData.sameBonusBoost
            }
            if (l.ajaxData.excludePattern && l.ajaxData.excludePattern.select) {
                a.excludePattern = l.ajaxData.excludePattern.select
            }
            if (l.ajaxData.excludePattern && l.ajaxData.excludePattern.addition) {
                l.ability.excludePattern = l.ajaxData.excludePattern.addition
            }
        }
        k.push(Ext.create("PSO2.ResultPanel", Ext.apply({
            frame: true,
            noDD: l.noDD,
            abilityComponent: l.ability,
            boostFunction: l.enableBoost ? l.boostFunction : null,
            listeners: {
                scope: l,
                opt1change: function(m, n, o) {
                    if (!m.suspendCheckChange) {
                        this.onAbilityOptionChange(m, n, o)
                    }
                },
                opt2change: function(m, n, o) {
                    if (!m.suspendCheckChange) {
                        this.onAbilityOptionChange(m, n, o);
                        this.updateCheckbox(m, this.tabPanel.activeTab.query("fieldset")[0])
                    }
                },
                opt3change: function(m, n, o) {
                    if (!m.suspendCheckChange) {
                        this.onAbilityOptionChange(m, n, o)
                    }
                }
            }
        }, a)));
        var b = Ext.create("Ext.panel.Panel", {
            flex: 1,
            frame: true,
            border: false,
            autoScroll: true,
            margin: "0 0 0 0",
            padding: "0 0 0 0",
            layout: "column",
            defaults: {
                columnWidth: 1 / 2,
                layout: "anchor",
                autoHeight: true,
                defaults: {
                    anchor: "100%"
                }
            },
            items: k,
            getFieldSet: function() {
                var m = this;
                if (!m.fieldSet) {
                    m.fieldSet = m.query("fieldset")[0]
                }
                return m.fieldSet
            },
            getResultPanel: function() {
                var m = this;
                if (!m.resultPanel) {
                    m.resultPanel = m.query("resultpanel")[0]
                }
                return m.resultPanel
            },
            updateResults: function() {
                if (l.initializedRestoreData !== true) {
                    var m = this.getFieldSet(),
                        n = this.getResultPanel();
                    n.updateResults(m)
                }
            }
        });
        if (l.initializedRestoreData === true) {
            var g = b.getFieldSet(),
                f = b.getResultPanel();
            g.on("afterrender", function(p, o) {
                var t = this,
                    s = d.r;
                b.updateResults();
                if (s) {
                    var u = s.split("."),
                        n = t.query("checkbox"),
                        m, q;
                    o.myComponent.initializedCheckbox = false;
                    if (Ext.isArray(n) && (m = n.length) > 0) {
                        for (q = 0; q < m; q++) {
                            if (0 <= Ext.Array.indexOf(u, n[q].inputValue)) {
                                n[q].setValue(true)
                            }
                        }
                    }
                    o.myComponent.initializedCheckbox = true
                }
            }, g, {
                delay: 1000,
                myComponent: l
            });
            f.on("afterrender", function(q, p) {
                var s = this,
                    t = d.o;
                if (t) {
                    var n = t.split("."),
                        m = n.length,
                        r;
                    p.myComponent.initializedSelectOption = false;
                    for (r = 0; r < m; r++) {
                        s.selectOption(n[r])
                    }
                    p.myComponent.initializedSelectOption = true
                }
            }, f, {
                delay: 1000,
                myComponent: l
            })
        }
        var c = [l.createGridPanel(0, l.ability.createSlotStore(), b, d ? d.s : null)];
        for (var e = 1; e <= l.maxMaterial; e++) {
            c.push(l.createGridPanel(e, l.ability.createSlotStore(), b, d ? d[e] : null))
        }
        var h = l.tabPanel.add({
            title: "Synthesis Panel",
            autoScroll: true,
            closable: true,
            fillDuster: function() {
                var o = this.query("gridpanel"),
                    n, m = 0;
                for (n = 0; n < o.length; n++) {
                    m = Math.max(m, o[n].getAbilityCount())
                }
                l.initializedRestoreData = true;
                try {
                    for (n = 0; n < o.length; n++) {
                        if (n == 0) {
                            o[n].fillDuster(m)
                        } else {
                            if (0 < o[n].getAbilityCount()) {
                                o[n].fillDuster(m)
                            }
                        }
                    }
                } finally {
                    l.initializedRestoreData = false
                }
                b.updateResults();
                l.onChangeAbility()
            },
            layout: {
                type: "vbox",
                align: "stretch",
                padding: "0 0 5 0"
            },
            items: [{
                layout: "column",
                defaults: {
                    columnWidth: 1 / (l.maxMaterial + 1),
                    layout: "anchor",
                    autoHeight: true,
                    defaults: {
                        anchor: "100%"
                    }
                },
                items: c
            }, b],
            getResultPanel: b.getResultPanel
        });
        l.addLocationHash(h);
        if (l.initializedRestoreData !== true) {
            l.updateLocationHash()
        }
        return h
    },
    saveData: function() {
        var b = this;
        if (b.tabPanel.activeTab) {
            var a = b.findLocationHashBy(b.tabPanel.activeTab);
            if (0 <= a) {
                var c = b.locationHash[a];
                if (b.urlHashValidate(c)) {
                    return Ext.Msg.prompt("Save Panel", "Panel state was saved to a cookie.<br/>Input a name?", function(e, g) {
                        if (e == "ok") {
                            var d = PSO2.Cookie.get(b.constCookieName) || {},
                                f = {};
                            if (g == "") {
                                g = Ext.Date.format(new Date(), "Y-m-d H:i:s")
                            }
                            b.hashcopy(b.locationHash[a], f);
                            if (d[g]) {
                                Ext.Msg.confirm("Confirm", "Data of the same name exists. Overwrite?", function(h) {
                                    if (h == "yes") {
                                        d[g] = f;
                                        PSO2.Cookie.set(b.constCookieName, d);
                                        Ext.Msg.alert("Information", "Save complete.")
                                    }
                                }, b)
                            } else {
                                d[g] = f;
                                PSO2.Cookie.set(b.constCookieName, d);
                                Ext.Msg.alert("Information", "Save complete.")
                            }
                        }
                    }, b)
                }
            }
        }
        return Ext.Msg.alert("Save Panel", "There is nothing to save.")
    },
    loadData: function() {
        var c = this,
            b = PSO2.Cookie.get(c.constCookieName);
        if (b && Ext.isObject(b)) {
            var d = [],
                e, a;
            for (e in b) {
                d.unshift({
                    key: e,
                    value: b[e]
                })
            }
            if (c.noDD === true) {
                a = {
                    scope: c,
                    itemclick: function(g, f) {
                        this.selectLoadData(g, f);
                        Ext.WindowMgr.getActive().close()
                    }
                }
            } else {
                a = {
                    scope: c,
                    itemdblclick: function(g, f) {
                        this.selectLoadData(g, f);
                        Ext.WindowMgr.getActive().close()
                    }
                }
            }
            Ext.create("widget.window", {
                title: "Load Panel",
                modal: true,
                width: c.noDD === true ? Ext.getBody().getWidth() : 600,
                height: 320,
                layout: "fit",
                autoDestroy: true,
                closable: true,
                items: Ext.create("Ext.view.View", {
                    anchor: "100%",
                    autoScroll: true,
                    allowBlank: false,
                    store: Ext.create("Ext.data.Store", {
                        model: "PSO2.CookieModel",
                        data: d
                    }),
                    tpl: ['<tpl for=".">', '<div class="cookie-wrap">', '<div class="cookie">{key}</div>', "</div>", "</tpl>", '<div class="x-clear"></div>'],
                    listeners: a,
                    trackOver: true,
                    overItemCls: "x-item-over",
                    itemSelector: "div.cookie-wrap"
                }),
                dockedItems: [{
                    xtype: "toolbar",
                    ui: "footer",
                    dock: "bottom",
                    layout: {
                        pack: "center"
                    },
                    items: Ext.create("Ext.button.Button", {
                        text: "Close",
                        scope: c,
                        handler: function() {
                            Ext.WindowMgr.getActive().close()
                        },
                        minWidth: 105
                    })
                }]
            }).show()
        } else {
            Ext.Msg.alert("Load Panel", "Panel was not restored.");
        }
    },
    selectLoadData: function(b, f) {
        var e = this;
        if (f) {
            var a, d, c;
            if (Ext.isFunction(f.get)) {
                a = f.get("value")
            } else {
                a = f
            }
            e.initializedRestoreData = true;
            try {
                d = e.addTab(a)
            } finally {
                e.initializedRestoreData = false
            }
            e.hashcopy(a, e.addLocationHash(d));
            e.updateLocationHash();
            e.tabPanel.setActiveTab(d)
        }
    },
    onAbilityOptionChange: function(c, f, h) {
        var e = this,
            b = e.findLocationHashBy(e.tabPanel.activeTab),
            g = f.value.charAt(0);
        if (e.locationHash[b]) {
            var a = e.locationHash[b]["o"].split("."),
                d = [];
            Ext.Array.forEach(a, function(k) {
                if (0 < k.length && k.charAt(0) != g) {
                    d.push(k)
                }
            });
            if (!h) {
                d.push(f.value)
            }
            e.locationHash[b]["o"] = d.join(".");
            e.updateLocationHash()
        }
    },
    makeFactor: function(b, a) {
        var c;
        if (a == true) {
            c = Ext.applyIf({
                source: b,
                factor: true,
                extend: null,
                generate: null
            }, b);
            c.code = "*" + b.code
        } else {
            c = b.source;
            delete b
        }
        return c
    },
    createGridPanel: function(e, k, b, h) {
        var f = this,
            a, d = b.getResultPanel(),
            g, c = [];
        for (i = 0; i <= f.maxMaterial; i++) {
            if (i != e) {
                c.push(i)
            }
        }
        d.bindStore(k);
        k.on({
            scope: b,
            update: b.updateResults
        });
        k.on({
            scope: f,
            update: f.onChangeAbility
        });
        a = Ext.create("Ext.grid.Panel", {
            title: f.panelNames[e],
            titleIndex: c,
            sortableColumns: false,
            dustAbilities: f.ability.abilityStore.getRange(f.ability.abilityStore.find("gid", "F")),
            getAbilityCount: function() {
                var m = this.store;
                return m.getEnableData().length - m.getFactorCount();
            },
            locked: false,
            collapsed: false,
            collapsible: true,
            collapseCls: "-collapse-",
            lockedCls: "slot-grid-locked",
            listeners: {
                scope: f,
                beforecollapse: function(r, q, m, o) {
                    if (r.tools[0] && r.tools[0].rendered) {
                        var n = r.tools[0];
                        if (r.locked === true) {
                            n.toolEl.removeCls(n.componentCls + r.collapseCls + n.expandType);
                            n.toolEl.addCls(n.componentCls + r.collapseCls + r.collapseDirection);
                            r.el.removeCls(r.lockedCls)
                        } else {
                            n.toolEl.removeCls(n.componentCls + r.collapseCls + r.collapseDirection);
                            n.toolEl.addCls(n.componentCls + r.collapseCls + n.expandType);
                            r.el.addCls(r.lockedCls)
                        }
                        r.locked = !r.locked
                    }
                    return false
                }
            },
            fillDuster: function(n) {
                var p, o, m;
                n = Math.min(n + this.store.getFactorCount(), this.store.getCount());
                if (this.getAbilityCount() <= n) {
                    p = 0;
                    while (p < n && (m = this.store.getAt(p).get("slot")) != null) {
                        if (m.gid == "F") {
                            this.store.removeAbility(m, p)
                        } else {
                            p++
                        }
                    }
                    for (o = p = 0; p < n; p++) {
                        m = this.store.getAt(p).get("slot");
                        if (m == null) {
                            this.store.addAbility(this.dustAbilities[o++].data)
                        }
                    }
                    this.view.refresh()
                }
            },
            columns: [{
                dataIndex: "name",
                header: "Slot",
                width: 52,
                hidden: f.noDD || 2 < f.maxMaterial
            }, {
                dataIndex: "slot",
                header: "Ability",
                renderer: function(q, n, m, r, p, o) {
                    if (q != null) {
                        if (q.factor) {
                            n.tdCls = "x-factor-icon"
                        }
                        return q.name
                    }
                    return ""
                }
            }],
            forceFit: true,
            store: k,
            viewConfig: {
                listeners: f.initDDListener(f.noDD)
            }
        });
        if (h) {
            var l = f.ability.getAbilityStore();
            Ext.Array.forEach(h.split("."), function(n) {
                var m = (n.substr(0, 1) == "*"),
                    o = l.findRecord("code", m ? n.substr(1) : n);
                if (o) {
                    a.store.addAbility(m ? f.makeFactor(o.data, true) : o.data)
                }
            })
        }
        return a
    },
    initDDListener: function(c) {
        var b = this,
            a = {
                scope: b
            };
        if (c !== true) {
            a.render = b.initializeSlotDropZone;
            a.cellcontextmenu = function(m, n, k, f, o, l, g) {
                g.stopEvent();
                if (f.get("slot") != null) {
                    b.selectedGridCell = {
                        view: m,
                        record: f,
                        rowIndex: l
                    };
                    if (f.get("slot").factor !== true) {
                        b.gridMenu.items.getAt(0).setText(b.factorMenuText.on)
                    } else {
                        b.gridMenu.items.getAt(0).setText(b.factorMenuText.off)
                    }
                    var h = [],
                        d;
                    Ext.Array.forEach(this.tabPanel.getActiveTab().query("grid"), function(e) {
                        if (e.getView() !== m) {
                            h.push(e)
                        }
                    });
                    for (d = 0; d < b.maxMaterial; d++) {
                        b.copyButtonUpdate(m, b.gridMenu.items.getAt(d + 1), d, h[d])
                    }
                    b.gridMenu.showAt(g.getXY())
                }
            }
        } else {
            a.cellclick = function(g, d, h, f, m, n, l) {
                l.stopEvent();
                if (g.panel && g.panel.locked === true) {
                    return false
                }
                b.selectedGridCell = {
                    view: g,
                    record: f,
                    rowIndex: n
                };
                if (f.get("slot") != null) {
                    if (f.get("slot").factor !== true) {
                        b.gridMenu.items.getAt(0).setText(b.factorMenuText.on)
                    } else {
                        b.gridMenu.items.getAt(0).setText(b.factorMenuText.off)
                    }
                    var k = [];
                    Ext.Array.forEach(this.tabPanel.getActiveTab().query("grid"), function(e) {
                        if (e.getView() !== g) {
                            k.push(e)
                        }
                    });
                    for (i = 0; i < b.maxMaterial; i++) {
                        b.copyButtonUpdate(g, b.gridMenu.items.getAt(i + 1), i, k[i])
                    }
                    b.gridMenu.showAt(l.getXY())
                } else {
                    b.abilityWindow.setWidth(b.mainPanel.getWidth());
                    b.abilityWindow.setHeight(Ext.getBody().getHeight());
                    b.abilityWindow.showAt(0, 0)
                }
            }
        }
        return a
    },
    copyButtonUpdate: function(b, e, d, c) {
        var f = this,
            a = b.ownerCt;
        e.setText("Copy to " + f.panelNames[a.titleIndex[d]]);
        e.targetView = c;
        return e
    },
    onCopyAbility: function(a) {
        var c = this,
            b = c.selectedGridCell;
        if (b && a.targetView) {
            a.targetView.getStore().addAbility(b.record.get("slot"))
        }
        this.selectedGridCell = null
    },
    initializeAbilityDragZone: function(a) {
        a.dragZone = Ext.create("Ext.dd.DragZone", a.getEl(), {
            getDragData: function(c) {
                var b = c.getTarget(a.itemSelector, 10),
                    f;
                if (b) {
                    f = b.cloneNode(true);
                    f.id = Ext.id();
                    return a.dragData = {
                        gridId: this.id,
                        sourceEl: b,
                        repairXY: Ext.fly(b).getXY(),
                        ddel: f,
                        patientData: a.getRecord(b).data
                    }
                }
            },
            getRepairXY: function() {
                return this.dragData.repairXY
            }
        })
    },
    initializeSlotDropZone: function(a) {
        var c = this,
            d = a,
            b = d.up("gridpanel");
        a.dragZone = Ext.create("Ext.dd.DragZone", a.getEl(), {
            getDragData: function(g) {
                var f = g.getTarget(a.itemSelector, 10),
                    h;
                if (f) {
                    if (!a.getRecord(f).data.slot) {
                        return null
                    }
                    h = f.cloneNode(true);
                    h.id = Ext.id();
                    return a.dragData = {
                        gridId: this.id,
                        sourceEl: f,
                        repairXY: Ext.fly(f).getXY(),
                        ddel: h,
                        patientData: a.getRecord(f).data.slot
                    }
                }
            },
            beforeInvalidDrop: function(h, g, l) {
                var f = this.dragData.sourceEl,
                    k = a.getRecord(f);
                if (k && !Ext.get(h) && !d.panel.locked) {
                    k.store.removeAbility(k, f.viewIndex);
                    a.refresh();
                    this.proxy.hide()
                }
            },
            getRepairXY: function() {
                return this.dragData.repairXY
            }
        });
        b.dropZone = Ext.create("Ext.dd.DropZone", a.el, {
            getTargetFromEvent: function(f) {
                return f.getTarget(".x-grid-cell-last")
            },
            onNodeDrop: function(k, f, h, g) {
                if (d.panel && d.panel.locked) {
                    return true
                }
                if (this.id == g.gridId) {
                    d.getStore().swapAbility(g.sourceEl.viewIndex, h.getTarget(d.itemSelector).viewIndex);
                    d.refresh();
                    c.onChangeAbility()
                } else {
                    d.getStore().addAbility(g.patientData)
                }
                return true
            }
        })
    },
    onChangeAbility: function() {
        var f = this,
            e, d, a, b;
        if (f.initializedRestoreData !== true) {
            e = this.tabPanel.activeTab;
            d = e && e.query("resultpanel")[0];
            a = d && d.abilitySet;
            b = f.findLocationHashBy(e);
            if (a && f.locationHash[b]) {
                f.locationHash[b]["s"] = a.getLocationHash(0).join(".");
                for (var c = 0; c <= f.maxMaterial; c++) {
                    f.locationHash[b][c] = a.getLocationHash(c).join(".")
                }
                f.locationHash[b]["r"] = d.getValues().join(".");
                f.updateLocationHash()
            }
        }
    },
    onCheckAbility: function(e, d) {
        var c = this,
            b = e.resultPanel;
        if (b) {
            if (d) {
                b.addAbility(e)
            } else {
                b.removeAbility(e)
            }
            c.updateCheckbox(b, e.fieldSet);
            if (c.tabPanel.activeTab) {
                var a = c.findLocationHashBy(c.tabPanel.activeTab);
                if (0 <= a) {
                    c.locationHash[a]["r"] = b.getValues().join(".");
                    c.updateLocationHash()
                }
            }
        }
    },
    updateCheckbox: function(c, a) {
        var b = a.query("checkbox");
        if (c.abilityCount() < c.getEnableMaxCount()) {
            Ext.Array.forEach(b, function(d) {
                if (d.disabled) {
                    d.enable()
                }
            })
        } else {
            Ext.Array.forEach(b, function(d) {
                if (!d.checked) {
                    d.disable()
                }
            })
        }
    },
    findLocationHashBy: function(b) {
        var d = this,
            a = d.locationHash.length,
            c;
        for (c = 0; c < a; c++) {
            if (d.locationHash[c]["id"] == b.id) {
                return c
            }
        }
        return -1
    },
    addLocationHash: function(a, d) {
        var c = this,
            e, b;
        if (c.initializedRestoreData === true && d !== true) {
            return location.hash
        }
        c.locationHash = c.locationHash || [];
        e = {
            id: a.id,
            s: "",
            r: "",
            o: ""
        };
        for (b = 1; b <= c.maxMaterial; b++) {
            e[b] = ""
        }
        c.locationHash.push(e);
        return e
    },
    removeLocationHash: function(a) {
        var c = this,
            b = c.findLocationHashBy(a),
            d;
        if (c.initializedRestoreData === true) {
            return location.hash
        }
        if (0 <= b) {
            d = c.locationHash.splice(b, 1)
        }
        c.updateLocationHash();
        return d
    },
    updateLocationHash: function() {
        var c = this,
            d = "",
            a = c.locationHash.length,
            b;
        if (c.initializedRestoreData !== true && c.initializedCheckbox !== false && c.initializedSelectOption !== false) {
            if (0 < a) {
                d = "#!";
                for (b = 0; b < a && b < c.limitUrlSize; b++) {
                    d += "/";
                    d += c.hashmake(c.locationHash[b])
                }
            }
            if (location.hash != d) {
                location.hash = d
            }
        }
    },
    onChangeLocationHash: function() {
        var o = this,
            k = o.locationHash || [],
            r = o.ability.abilityStore;
        if (location && location.hash) {
            if (location.hash.match(/^#!([a-zA-Z0-9]+)$/)) {
                return location.hash = "!/" + lzbase62.decompress(RegExp.$1)
            } else {
                if (location.hash.match(/^#!\/([a-zA-Z0-9\.\=&\/\*]+)/)) {
                    var e = RegExp.$1.split("/"),
                        m = e.length,
                        g;
                    for (g = 0; g < m && g < o.limitUrlSize; g++) {
                        if (g < k.length) {
                            if (e[g] != o.hashmake(k[g])) {
                                var b = Ext.urlDecode(e[g]);
                                if (o.urlHashValidate(b)) {
                                    var c = Ext.getCmp(k[g].id),
                                        h = c.getResultPanel(),
                                        l = h.ownerCt.getFieldSet(),
                                        n = b.r.split("."),
                                        d = c.query("grid"),
                                        q = function(v, y) {
                                            var p = v.store.count(),
                                                s = y.split("."),
                                                x, u, w;
                                            for (var t = 0; t < p; t++) {
                                                x = s.shift();
                                                if (x) {
                                                    u = (x.substr(0, 1) == "*");
                                                    w = r.findRecord("code", u ? x.substr(1) : x);
                                                    if (w) {
                                                        v.store.getAt(t).data.slot = (u ? o.makeFactor(w.data, true) : w.data)
                                                    }
                                                } else {
                                                    v.store.getAt(t).data.slot = null
                                                }
                                            }
                                            v.getView().refresh()
                                        };
                                    q(d[0], b.s);
                                    for (var f = 1; f <= o.maxMaterial; f++) {
                                        q(d[f], b[f])
                                    }
                                    h.suspendCheckChange = 1;
                                    h.ownerCt.updateResults();
                                    l.items.each(function(p) {
                                        p.suspendCheckChange = 1;
                                        if (0 <= n.indexOf(p.inputValue)) {
                                            p.setValue(true);
                                            h.addAbility(p, true)
                                        } else {
                                            p.setValue(false);
                                            h.removeAbility(p, true)
                                        }
                                        p.suspendCheckChange = 0
                                    });
                                    h.refresh();
                                    o.updateCheckbox(h, l);
                                    Ext.Array.forEach(b.o.split("."), function(p) {
                                        h.selectOption(p)
                                    });
                                    h.refresh();
                                    o.updateCheckbox(h, l);
                                    h.suspendCheckChange = 0;
                                    o.hashcopy(b, k[g])
                                }
                            }
                        } else {
                            var b = Ext.urlDecode(e[g]);
                            o.initializedRestoreData = true;
                            try {
                                o.hashcopy(b, o.addLocationHash(o.addTab(b), true))
                            } finally {
                                o.initializedRestoreData = false
                            }
                        }
                    }
                    if (g < k.length) {
                        var a = [];
                        while (g != k.length) {
                            a.push((k.pop())["id"])
                        }
                        Ext.Array.forEach(a, function(s) {
                            var p = Ext.getCmp(s);
                            if (p) {
                                p.close()
                            }
                        })
                    }
                }
            }
        }
    },
    hasharray: function(d) {
        var c = this,
            a = [d.s, d.r],
            b;
        for (b = 1; b <= c.maxMaterial; b++) {
            a.push(d[b])
        }
        return a
    },
    hashmake: function(d) {
        var c = this,
            b, a = "";
        a += c.makeHashParameter(d, "s");
        for (b = 1; b <= c.maxMaterial; b++) {
            a += "&" + c.makeHashParameter(d, b)
        }
        a += "&" + c.makeHashParameter(d, "r");
        a += "&" + c.makeHashParameter(d, "o");
        return a
    },
    hashcopy: function(d, a) {
        var c = this,
            b;
        a.s = d.s;
        a.r = d.r;
        a.o = d.o;
        for (b = 1; b <= c.maxMaterial; b++) {
            a[b] = d[b]
        }
    },
    makeHashParameter: function(b, a) {
        return a + "=" + (b[a] ? b[a] : "")
    }
});