/*

This file is part of Ext JS 4

Copyright (c) 2011 Sencha Inc

Contact:  http://www.sencha.com/contact

GNU General Public License Usage
This file may be used under the terms of the GNU General Public License version 3.0 as published by the Free Software Foundation and appearing in the file LICENSE included in the packaging of this file.  Please review the following information to ensure the GNU General Public License version 3.0 requirements will be met: http://www.gnu.org/copyleft/gpl.html.

If you are unsure which license is appropriate for your use, please contact the sales department at http://www.sencha.com/contact.

*/
Ext.ns("PSO2");
Ext.define("PSO2.CookieModel", {
    extend: "Ext.data.Model",
    idProperty: "key",
    fields: [{
        name: "key"
    }, {
        name: "value"
    }]
});
PSO2.Cookie = {
    expiresDay: 60,
    version: "1.1",
    vText: "__version",
    init: function() {
        PSO2.Cookie.cookieProvider = Ext.create("Ext.state.CookieProvider", {
            path: location.pathname,
            domain: location.hostname,
            expires: new Date(new Date().getTime() + (86400000 * PSO2.Cookie.expiresDay))
        });
        Ext.state.Manager.setProvider(PSO2.Cookie.cookieProvider)
    },
	// Returns all affix plans saved to the cookie
    get: function(cookieName) {
        if (!Ext.isDefined(PSO2.Cookie.cookieProvider)) {
            PSO2.Cookie.init()
        }
        var tmpPlanList = PSO2.Cookie.cookieProvider.get(cookieName),
            version = PSO2.Cookie.cookieProvider.get(cookieName + PSO2.Cookie.vText),
            savedPlanList = null;
		// Determine how to save the plans
		// If version number is the same, can pass it
		// If not, parse it and pass it
        if (Ext.isDefined(version)) {
            if (version == PSO2.Cookie.version) {
                savedPlanList = tmpPlanList
            }
        } else {
            try {
                savedPlanList = JSON.parse(tmpPlanList)
            } catch (d) {}
        }
        return savedPlanList
    },
    set: function(cookieName, savedPlanList) {
        if (!Ext.isDefined(PSO2.Cookie.cookieProvider)) {
            PSO2.Cookie.init()
        }
        if (Ext.isObject(savedPlanList)) {
            PSO2.Cookie.cookieProvider.set(cookieName, savedPlanList);
            PSO2.Cookie.cookieProvider.set(cookieName + PSO2.Cookie.vText, PSO2.Cookie.version)
        }
    }
};
PSO2.utils = {
    overflow: function(a, c, b) {
        if (a < c) {
            return a - 1
        }
        return Math.max(0, c - b)
    }
};
Ext.ns("PSO2");
Ext.define("PSO2.Ability", {
    extend: "Ext.data.Model",
    fields: ["code", "gid", "name", "lvup", "extend", "generate", "require", "extup", "status", "effect"]
});
Ext.define("PSO2.Slot", {
    extend: "Ext.data.Model",
    fields: ["id", "name", "slot"]
});
Ext.define("PSO2.AbilitySet", {
    extend: "Ext.Base",
    mutationICd: "OA01",
    mutationIICd: "OA02",
    photonCd: "WA01",
	// Constucts the ability set for the panel
    constructor: function(inAbilitySet) {
        var abilitySet = this,
            abilityEntry;
        Ext.apply(abilitySet, inAbilitySet);
		// Find id of Mutation I, Mutation II, and Photon Collect for boost upgrade calculations
        if (abilitySet.abilityStore) {
            abilityEntry = abilitySet.abilityStore.findRecord("name", "Mutation I");
            if (abilityEntry) {
                abilitySet.mutationICd = abilityEntry.get("code")
            }
            abilityEntry = abilitySet.abilityStore.findRecord("name", "Mutation II");
            if (abilityEntry) {
                abilitySet.mutationIICd = abilityEntry.get("code")
            }
            abilityEntry = abilitySet.abilityStore.findRecord("name", "Photon Collect");
            if (abilityEntry) {
                abilitySet.photonCd = abilityEntry.get("code")
            }
        }
        abilitySet.stores = [];
        abilitySet.clear()
    },
	// Returns list of affixes on the fodder
    getEnableData: function(fodderIndex) {
        return this.stores[fodderIndex].getEnableData()
    },
	// Returns count of SAF on the fodder
    getFactorCount: function(fodderIndex) {
        return this.stores[fodderIndex].getFactorCount()
    },
	// Returns list of id on the fodder
    getLocationHash: function(fodId) {
        var abilitySet = this,
            fodder = abilitySet.stores[fodId],
            codeList = "";
        if (fodder) {
            codeList = fodder.getEnableDataCd()
        }
        return codeList
    },
	// Push a fodder into the fodder list. True if has not existed
    putStore: function(store) {
        var a = (Ext.Array.indexOf(this.stores, store) < 0);
        if (a) {
            this.stores.push(store)
        }
        return a
    },
	// Push affix onto processing stack?
    put: function(ability) {
        var abilitySet = this,
            c, b = ability;
        if (!abilitySet.hashStack[ability.code]) {
            abilitySet.hashStack[ability.code] = 0
        }
        c = ++abilitySet.hashStack[ability.code];
        if (Ext.isArray(ability.extend)) {
            if (0 < ability.extend[abilitySet.overflow(ability.extend.length, c, 1)] && Ext.Array.indexOf(abilitySet.stack, ability) < 0) {
                abilitySet.stack.push(ability)
            }
        }
    },
	// Returns true if exists in the panel
    isMutationI: function() {
        var abilitySet = this;
        return 0 < abilitySet.hashStack[abilitySet.mutationICd]
    },
    isMutationII: function() {
        var abilitySet = this;
        return 0 < abilitySet.hashStack[abilitySet.mutationIICd]
    },
    isPhotonCollect: function() {
        var abilitySet = this;
        return 0 < abilitySet.hashStack[abilitySet.photonCd]
    },
	// Number of material being used
    enableMaterial: function() {
        var abilitySet = this,
            len = abilitySet.stores.length,
            c = 0;
        for (var b = 1; b < len; b++) {
            if (abilitySet.stores[b].exist()) {
                c++
            }
        }
        return c
    },
	// Returns the max amount of slots can be used
    enableMaterialMaxCount: function() {
        return Math.min(this.enableCheckMax, this.stores[0].count() - 1)
    },
    forEach: function(func, resultPanel) { // Called by ln 1746
        var abilitySet = this,
            resultPanel = [],
            e;
        for (e in abilitySet.hashStack) {
            resultPanel.push(e)
        }
        for (e in abilitySet.levelupHashStack) {
            resultPanel.push(e)
        }
        for (e in abilitySet.refHashStack) {
            resultPanel.push(e)
        }
        resultPanel = resultPanel.filter(function(f, h, g) {
            return g.indexOf(f) === h
        }).sort();
        for (i = 0; i < resultPanel.length; i++) {
            if (resultPanel[i]) {
                if (resultPanel[i].substr(0, 1) == "*") {
                    func.call(resultPanel, abilitySet.abilityStore.findRecord("code", resultPanel[i].substr(1))["data"], true)
                } else {
                    func.call(resultPanel, abilitySet.abilityStore.findRecord("code", resultPanel[i])["data"], false)
                }
            }
        }
    },
    // Resets the panel and calculates if the setup is valid
    // and produces the list of possible affixes
    resetAbility: function() {
        var abilitySet = this,
            numFodder = abilitySet.stores.length,
            minAbilityCountRequire = abilitySet.getEnableData(0).length - abilitySet.getFactorCount(0),
            b;
        if (minAbilityCountRequire == 0) {
            b = false;
            for (i = 1; i < numFodder; i++) {
                if (0 < abilitySet.getEnableData(i).length) {
                    b = true;
                    break
                }
            }
        } else {
            b = true;
            for (i = 1; i < numFodder; i++) {
                var affixCount = abilitySet.getEnableData(i).length - abilitySet.getFactorCount(i);
                if (0 < affixCount && affixCount < minAbilityCountRequire) {
                    b = false;
                    break
                }
            }
        }
        abilitySet.clear();
        if (b == true) {
            for (i = 0; i < numFodder; i++) {
                Ext.Array.forEach(abilitySet.getEnableData(i), abilitySet.put, abilitySet)
            }
            abilitySet.enableCheckMax = minAbilityCountRequire + 1;
            abilitySet.resetLevelupAbility();
            abilitySet.resetExtendAbility()
        }
    },
    clear: function() {
        var abilitySet = this;
        abilitySet.enableCheckMax = 0;
        abilitySet.stack = [];
        abilitySet.hashStack = {};
        abilitySet.levelupStack = [];
        abilitySet.levelupHashStack = {};
        abilitySet.exStack = {};
        abilitySet.refStack = [];
        abilitySet.refHashStack = {};
        abilitySet.refBonusStack = {}
    },
    // Returns index of the code in the list
    indexOf: function(abiValidSelList, key, code) {
        var a = abiValidSelList.length;
        for (var index = 0; index < a; index++) {
            if (abiValidSelList[index][key] == code) {
                return index
            }
        }
        return -1
    },
    // Returns list of code of the affixes in the hash stack
    getKeyList: function(hashStack) {
        var arrayCode = [];
        for (var abilityCode in hashStack) {
            arrayCode.push(abilityCode)
        }
        return arrayCode
    },
    // Finds all valid lvl up affix and push onto levelupStack
    resetLevelupAbility: function() {
        var abilitySet = this,
            arrayCode = abilitySet.getKeyList(abilitySet.hashStack),
            codeLen = arrayCode.length,
            entryIndex, lvlupCode, numCopies, lvlupAffix, baseAffix;
        for (var index = 0; index < codeLen; index++) {
            numCopies = abilitySet.hashStack[arrayCode[index]];
            // If there is more than 1 copy, then it may lvl up
            if (1 < numCopies) {
                entryIndex = abilitySet.indexOf(abilitySet.stack, "code", arrayCode[index]);
                if (0 <= entryIndex) {
                    // Find associate code for lvl up
                    lvlupCode = abilitySet.stack[entryIndex]["lvup"];
                    if (lvlupCode && !abilitySet.levelupHashStack[lvlupCode]) {
                        lvlupAffix = abilitySet.abilityStore.findRecord("code", lvlupCode)["data"];
                        // Determine if it is possible to lvl up with number of copies atm
                        if (lvlupAffix.generate && lvlupAffix.generate[Math.min(lvlupAffix.generate.length - 1, numCopies - 2)]) {
                            // Determine if the base affix has a requirement for lvl up (Gift)
                            // to determine if push onto lvlup stack
                            baseAffix = abilitySet.abilityStore.findRecord("code", arrayCode[index]);
                            if (baseAffix.get("require")) {
                                if (abilitySet.hashStack[baseAffix.get("require")]) {
                                    abilitySet.levelupStack.push(lvlupAffix);
                                    abilitySet.levelupHashStack[lvlupCode] = abilitySet.hashStack[arrayCode[index]]
                                }
                            } else {
                                // Push lvlup Affix and stores the number of copies are being used
                                abilitySet.levelupStack.push(lvlupAffix);
                                abilitySet.levelupHashStack[lvlupCode] = abilitySet.hashStack[arrayCode[index]]
                            }
                        }
                    }
                }
            }
        }
    },
    // Searches for all extendAbility rules and adds affixes to the list according to the rule
    resetExtendAbility: function() {
        var abilitySet = this, 
        affixEntry;
        // For all affix in the hashstack, check if it has extup rule
        for (var affixCode in abilitySet.hashStack) {
            affixEntry = abilitySet.abilityStore.findRecord("code", affixCode);
            if (affixEntry && affixEntry.get("extup")) {
                // Enters all possible relation boost recipe to the list
                Ext.Array.forEach(affixEntry.get("extup"), function(extTarget) {
                    if (!abilitySet.exStack[extTarget]) { // new entry
                        abilitySet.exStack[extTarget] = [affixEntry.get("rel")]
                    } else { // existing
                        abilitySet.exStack[extTarget].push(affixEntry.get("rel"))
                    }
                })
            }
        }
        Ext.Array.forEach(abilitySet.abilityComponent.constExtendAbility, function(relRule) {
            var localAbilitySet = this,
                rulTarget = localAbilitySet.getAbilityRefferer(relRule),
                targetIndex;
            // If there are valid targets for the rule
            if (rulTarget) {
                for (var index = 0; index < rulTarget.length; index++) {
                    if (relRule.success) {
                        targetIndex = localAbilitySet.indexOf(localAbilitySet.stack, "code", rulTarget[index]);
                        if (targetIndex < 0) {
                            // Target is added to the list due to the rule
                            if (localAbilitySet.indexOf(localAbilitySet.levelupStack, "code", rulTarget[index]) < 0) {
                                localAbilitySet.refStack.push(localAbilitySet.abilityStore.findRecord("code", rulTarget[index])["data"])
                            }
                        }
                        localAbilitySet.refHashStack[rulTarget[index]] = relRule.success
                    } else { // ???
                        if (relRule.bonus) {
                            localAbilitySet.refBonusStack[rulTarget[index]] = relRule.bonus
                        }
                    }
                }
            }
        }, abilitySet)
    },
    // Take extendAbility and searches for all valid targets
    getAbilityRefferer: function(extendAbility) {
        var abilitySet = this,
            base = extendAbility.base,
            baseLength = base.length,
            f = true,
            g = null,
            hashStack = Ext.apply({}, abilitySet.hashStack);
        for (var index = 0; index < baseLength; index++) {
            if (base[index].indexOf("*") < 0) {
                if (!hashStack[base[index]]) {
                    return null
                } else {
                    hashStack[base[index]]--
                }
            } else {
                // Capture the letter code of the rule
                var codeHeadCapture = new RegExp("([^*]+)", "g")
                var codeHead = base[index].match(codeHeadCapture)
                // If the head only has 1 letter, add [A-Z] capture to prevent capture of 2nd letter
                // since all codes have at least 2 letters
                if(codeHead[0].length == 1){ 
                    codeHead[0] += "[A-Z]"
                }
                var codeCapture = new RegExp("(" + codeHead[0] + "[^,]+" + ")", "g")
                
                var relTarget = abilitySet.getKeyList(hashStack).join(",").match(codeCapture);
                if (relTarget) {
                    g = relTarget
                } else {
                    return null
                }
            }
        }
        return (extendAbility.ref == "$$" && g) ? relTarget : Ext.isArray(extendAbility.ref) ? extendAbility.ref : [extendAbility.ref]
    },
    overflow: function(a, c, b) {
        if (a < c) {
            return a - 1
        }
        return Math.max(0, c - b)
    }
});
Ext.define("PSO2.AbilityStore", {
    extend: "Ext.data.Store",
    model: "PSO2.Ability",
    groupField: "gid",
    findRecord: function() {
        var entry = this.callParent(arguments);
        if (entry || !this.snapshot) {
            return entry
        }
        return this.findRecord2.apply(this, arguments)
    },
    find2: function(key, value, g, f, a, c) {
        var filter = this.createFilterFn(key, value, f, a, c);
        return filter ? this.snapshot.findIndexBy(filter, null, g) : -1
    },
    findRecord2: function() {
        var abStore = this,
            a = abStore.find2.apply(abStore, arguments);
        return a !== -1 ? abStore.getAt2(a) : null
    },
    getAt2: function(index) {
        return this.snapshot.getAt(index)
    }
});
Ext.define("PSO2.AbilityComponent", {
    extend: "Ext.Base",
    constAbility: [],
    constExtra: [],
    constBoostPoint: {},
    constExtendAbility: [],
    constBaseSlot: [{
        id: "slot01",
        name: "Slot 1",
        slot: null
    }, {
        id: "slot02",
        name: "Slot 2",
        slot: null
    }, {
        id: "slot03",
        name: "Slot 3",
        slot: null
    }, {
        id: "slot04",
        name: "Slot 4",
        slot: null
    }, {
        id: "slot05",
        name: "Slot 5",
        slot: null
    }, {
        id: "slot06",
        name: "Slot 6",
        slot: null
    }, {
        id: "slot07",
        name: "Slot 7",
        slot: null
    }, {
        id: "slot08",
        name: "Slot 8",
        slot: null
    }, {
        id: "slot09",
        name: "Slot 9",
        slot: null
    }],
    excludePattern: [],
    constructor: function(abiltiyStore) {
        Ext.apply(this, abiltiyStore);
        this.callParent(abiltiyStore)
    },
    getAbilityStore: function(a) {
        var abilityComponent = this;
        if (a === true) {
            return Ext.create("PSO2.AbilityStore", {
                data: abilityComponent.constAbility
            })
        } else {
            if (!abilityComponent.abilityStore) {
                // If abilityStore is not defined in abilityComponent, initialize
                abilityComponent.abilityStore = abilityComponent.getAbilityStore(true)
            }
        }
        return abilityComponent.abilityStore
    },
    // Checks the fodder contains all valid affixes
    isExistAbilities: function(fodderCodes) {
        var abilityComponent = this,
            abilityStore = abilityComponent.getAbilityStore(),
            len;
        if (!Ext.isArray(fodderCodes)) {
            fodderCodes = [fodderCodes]
        }
        len = fodderCodes.length;
        for (var index = 0; index < len; index++) {
            var code = fodderCodes[index];
            if (code.substr(0, 1) == "*") {
                code = code.substr(1)
            }
            if (0 > abilityStore.findBy(function(gridbox) {
                    if (gridbox.data.code == code) {
                        return true
                    }
                })) {
                return false
            }
        }
        return true
    },
    createSlotStore: function() {
        var abilityComponent = this,
            fodderSlot = Ext.create("Ext.data.Store", {
                model: "PSO2.Slot",
                data: this.constBaseSlot,
                // Checks if the two affixes should be excluded due to the rules
                chkFn: function(affix1, affix2) {
                    var excludePatterns = abilityComponent.excludePattern, 
                    match1, match2;
                    for (var i = 0; i < excludePatterns.length; i++) {
                        excludePattern = Ext.isArray(excludePatterns[i]) ? excludePatterns[i] : [excludePatterns[i]];
                        match1 = match2 = false;
                        for (var j = 0; j < excludePattern.length; j++) {
                            if (excludePattern[j] == affix2.substr(0, excludePattern[j].length)) {
                                match1 = true
                            }
                            if (excludePattern[j] == affix1.substr(0, excludePattern[j].length)) {
                                match2 = true
                            }
                        }
                        if (match1 && match2) {
                            return true
                        }
                    }
                    return false
                },
                addAbility: function(affix) {
                    var isSAF = affix.code.substr(0, 1) == "*",
                        code = isSAF ? affix.code.substr(1) : affix.code,
                        subID = code.substr(0, 2),
                        slot, slotCount = this.getCount(),
                        index;
                    for (index = 0; index < slotCount; index++) {
                        slot = this.getAt(index).get("slot");
                        if (slot == null) {
                            break
                        }
                        // If same, ignore
                        if ((slot.source && slot.source.code == code) || (slot.code == code)) {
                            return true
                        }
                        // If slot is SAF, check with original code. Else compare code directly
                        if ((slot.source && slot.source.code.substr(0, 2) == subID) || (slot.code.substr(0, 2) == subID)) {
                            // If slot is not SAF, matched found
                            if ((slot.code.substr(0, 1) != "*")) {
                                break
                            }
                        }
                        if (this.chkFn(affix.code, slot.code)) {
                            break
                        }
                    }

                    // Fodder is full
                    if (slotCount <= index) {
                        return false
                    }
                    return this.getAt(index).set("slot", affix)
                },
                exist: function() {
                    return this.getEnableData().length != 0
                },
                swapAbility: function(indDrag, indTarget) {
                    var slotCount = this.getCount(),
                        slot, g = 0;
                    if (indDrag == indTarget) {
                        return false
                    }
                    // Finds the last slot
                    while (g < slotCount && (slot = this.getAt(g).get("slot")) != null) {
                        g++
                    }
                    // If target is empty, swap with the last one
                    if (g <= indTarget) {
                        indTarget = g - 1
                    }
                    slot = this.getAt(indDrag).get("slot");
                    this.getAt(indDrag).data.slot = this.getAt(indTarget).get("slot");
                    this.getAt(indTarget).data.slot = slot;
                    return true
                },
                removeAbility: function(gridbox, index) {
                    var slotCount = this.getCount();
                    if ((slotCount - 1) == index) {
                        this.getAt(index).data.slot = null
                    } else {
                        // Shuffle down
                        for (var e = index; e < slotCount - 1; e++) {
                            this.getAt(e).data.slot = this.getAt(e + 1).get("slot");
                            this.getAt(e + 1).data.slot = null
                        }
                    }
                    this.fireEvent("update", this, gridbox, "delete", undefined)
                },
                getEnableData: function() {
                    var slotCount = this.getCount(),
                        result = [],
                        affixEntry;
                    for (var index = 0; index < slotCount; index++) {
                        affixEntry = this.getAt(index).get("slot");
                        if (affixEntry == null) {
                            break
                        }
                        result.push(affixEntry)
                    }
                    return result
                },
                getEnableDataCd: function() {
                    var affixList = this.getEnableData(),
                        result = [];
                    Ext.Array.forEach(affixList, function(entry) {
                        result.push(entry.code)
                    });
                    return result
                },
                getFactorCount: function() {
                    var affixList = this.getEnableData(),
                        count = 0;
                    Ext.Array.forEach(affixList, function(entry) {
                        if (entry.factor) {
                            count++
                        }
                    });
                    return count
                }
            });
        return fodderSlot
    },
    calcSuccess: function(abSet, affix) {
        var abComp = this,
            extend = affix.get("extend"),
            generate = affix.get("generate"),
            status = affix.get("status"),
            boost = affix.get("boost"),
            exBoost = affix.get("exboost"),
            code = affix.get("code"),
            haveMut1 = abSet.isMutationI(),
            haveMut2 = abSet.isMutationII(),
            havePhotCol = abSet.isPhotonCollect(),
            level = abComp.getLevel(affix.get("name")),
            refRate = 0,
            extendRate = 0,
            lvlupRate = 0,
            boostRate = 0,
            finalRate = 0,
            // Calculte bonus should be received from rule
            func = function(successRule, rate) {
                var mut1Bonus = 0,
                    mut2Bonus = 0,
                    resultBoost = 0,
                    extUpCode;
                if (abComp.constBoostPoint.mutation1[successRule] && abComp.constBoostPoint.mutation1[successRule][status]) {
                    mut1Bonus = haveMut1 ? abComp.constBoostPoint.mutation1[successRule][status][level] : 0
                }
                if (abComp.constBoostPoint.mutation2[successRule] && abComp.constBoostPoint.mutation2[successRule][status]) {
                    mut2Bonus = haveMut2 ? abComp.constBoostPoint.mutation2[successRule][status][level] : 0
                }
                extUpCode = abComp.indexOf(abSet.exStack, code);
                if (extUpCode) {
                    var boost = 0;
                    for (var y = 0; y < abSet.exStack[extUpCode].length; y++) {
                        if (abComp.constBoostPoint[abSet.exStack[extUpCode][y]][successRule] && abComp.constBoostPoint[abSet.exStack[extUpCode][y]][successRule][status]) {
                            if (Ext.isObject(abComp.constBoostPoint[abSet.exStack[extUpCode][y]][successRule][status][level])) {
                                // Gives boost to a max rate
                                var exBoost = abComp.constBoostPoint[abSet.exStack[extUpCode][y]][successRule][status][level]["boost"],
                                    exMax = abComp.constBoostPoint[abSet.exStack[extUpCode][y]][successRule][status][level]["max"];
                                boost = (rate + exBoost) <= exMax ? exBoost : Math.abs(exMax - rate)
                            } else {
                                // unconditional boost
                                boost = abComp.constBoostPoint[abSet.exStack[extUpCode][y]][successRule][status][level]
                            }
                        }
                        resultBoost = Math.max(resultBoost, boost)
                    }
                }
                return Math.max(mut1Bonus, mut2Bonus, resultBoost)
            };
        // Rate from extendAbility section of json
        if (abSet.refHashStack[code]) {
            refRate = abSet.refHashStack[code]
        }
        // Rate from extend section
        if (extend && abSet.hashStack[code]) {
            if (affix.get("require")) {
                if (abSet.hashStack[affix.get("require")]) {
                    extendRate = extend[abComp.overflow(extend.length, abSet.hashStack[code], 1)]
                }
            } else {
                extendRate = extend[abComp.overflow(extend.length, abSet.hashStack[code], 1)]
            }
        }
        // Rate from generate
        if (generate && abSet.levelupHashStack[code]) {
            var photonRate = 0;
            lvlupRate = generate[abComp.overflow(generate.length, abSet.levelupHashStack[code], 2)] + func("create", 0);
            if (abComp.constBoostPoint.photon["create"] && abComp.constBoostPoint.photon["create"][status]) {
                photonRate = havePhotCol ? abComp.constBoostPoint.photon["create"][status][level] : 0
            }
            lvlupRate = Math.max(lvlupRate, photonRate)
        }
        if (status) {
            if (refRate || extendRate) {
                boostRate = Math.max(refRate + func("extend", refRate), extendRate + func("extend", extendRate))
            }
        }
        finalRate = Math.max(Math.max(Math.max(refRate, extendRate), lvlupRate), boostRate);
        if (finalRate && abSet.refBonusStack[code]) { // never trigger
            finalRate += abSet.refBonusStack[code]
        }
        return Math.min(100, finalRate)
    },
    // Determines if the code is in the extup list and returns key
    indexOf: function(extup, code) {
        if (code && extup) {
            if (Ext.isArray(extup)) {
                for (i = 0; i < extup.length; i++) {
                    if (extup[i] && extup[i] == code.substr(0, extup[i].length)) {
                        return i
                    }
                }
            } else {
                if (Ext.isObject(extup)) {
                    for (var subcode in extup) {
                        if (subcode == code.substr(0, subcode.length)) {
                            return subcode
                        }
                    }
                    return null
                }
            }
        }
        return -1
    },
    overflow: function(a, c, b) {
        if (a < c) {
            return a - 1
        }
        return Math.max(0, c - b)
    },
    // Return affix entry from code
    findAbilityName: function(code) {
        var abComp = this,
            a = abComp.getAbilityStore();
        return a.findRecord("code", code)
    },
    // Return affix lvl
    getLevel: function(b) {
        var a = 0;
        if (0 < b.indexOf("IV")) {
            a = 4
        } else if (0 < b.indexOf("VI")) {
            a = 6
        } else if (0 < b.indexOf("V")) {
            a = 5
        } else if (0 < b.indexOf("III")) {
            a = 3
        } else if (0 < b.indexOf("II")) {
            a = 2
        } else if (0 < b.indexOf("I")) {
            a = 1
        }
        return a
    },
    // Final result list
    getSuccessList: function(b, selAffix, optItem) {
        var abComp = this,
            totalSel = (selAffix.length + optItem.length),
            isUpslot = b.enableCheckMax == totalSel,
            upslotBonus = (2 <= b.enableMaterial()),
            abilityStore = abComp.getAbilityStore(),
            len = selAffix.length,
            affixEntry, rate, result = [];
        for (var index = 0; index < len; index++) {
            var isSAF = (selAffix[index].inputValue.substr(0, 1) == "*");
            affixEntry = abilityStore.findRecord("code", isSAF ? selAffix[index].inputValue.substr(1) : selAffix[index].inputValue);
            var isExemptUpslot = affixEntry.get("noEx");
            if (affixEntry) {
                rate = isSAF ? 100 : abComp.calcSuccess(b, affixEntry);
                if (isUpslot && !isExemptUpslot) {
                    rate = parseInt((rate * abComp.constExtra[totalSel - 1][upslotBonus]) / 100)
                }
                result.push({
                    name: affixEntry.get("name"),
                    success: rate
                })
            }
        }
        len = optItem.length;
        for (var index = 0; index < len; index++) {
            rate = optItem[index].get("extend");
            if (isUpslot) {
                rate = parseInt((rate * abComp.constExtra[totalSel - 1][upslotBonus]) / 100)
            }
            result.push({
                name: optItem[index].get("name"),
                success: rate
            })
        }
        return result
    },
    // Check box selection list
    getSuccessList2: function(abSet, affixList) {
        var abComp = this,
            upslotBonus = (2 <= abSet.enableMaterial()),
            abilityStore = abComp.getAbilityStore(),
            d = affixList.length,
            affixEntry, successRate, rateList = {};
        for (var c = 0; c < d; c++) {
            var isSAF = (affixList[c]["code"].substr(0, 1) == "*");
            affixEntry = abilityStore.findRecord("code", isSAF ? affixList[c]["code"].substr(1) : affixList[c]["code"]);
            if (affixEntry) {
                successRate = isSAF ? 100 : abComp.calcSuccess(abSet, affixEntry);
                rateList[affixEntry.get("code")] = successRate
            }
        }
        return rateList
    }
});
Ext.ns("PSO2");
Ext.chart.theme.Browser = Ext.extend(Ext.chart.theme.Base, {
    constructor: function(a) {
        Ext.chart.theme.Base.prototype.constructor.call(this, Ext.apply({
            colors: ["rgb(0, 0, 255)", "rgb(127, 255, 0)", "rgb(255, 215, 0)", "rgb(255, 165, 0)", "rgb(255, 69, 0)", "rgb(128, 10, 128)", "rgb(128, 0, 0)", "rgb(64, 64, 64)", "rgb(0, 0, 0)", "rgb(32, 0, 0)"]
        }, a))
    }
});
Ext.define("PSO2.ResultPanel", {
    extend: "Ext.panel.Panel",
    alias: "widget.resultpanel",
    layout: "anchor",
    baseCls: Ext.baseCSSPrefix + "panel-body-default-framed " + Ext.baseCSSPrefix + "resultpanel",
    xtype: "resultpanel",
    padding: "0",
    autoHeight: true,
    suspendCheckChange: 0,
    constViewPanel: "-viewpanel",
    constSelOption1: "-selopt-1",
    constSelOption2: "-selopt-2",
    constSelOption3: "-selopt-3",
    constChkOption1: "-chkopt-1",
    constSuccessPanel: "-successpanel",
    emptyText: "&nbsp;",
    dodoButtonText: "Dudu It",
    redodoButtonText: "Dudu It Again",
    moreButtonText: "Success or +10,000",
    moreDodoLimit: 10000,
    monimoniButtonText: "Details",
    abText: ["S-ATK", "R-ATK", "T-ATK", "S-DEF", "R-DEF", "T-DEF", "DEX", "HP", "PP", "Strike Resist", "Range Resist", "Tech Resist", "Fire Resist", "Ice Resist", "Lightning Resist", "Wind Resist", "Light Resist", "Dark Resist"],
    allUp: ["S-ATK", "R-ATK", "T-ATK", "S-DEF", "R-DEF", "T-DEF", "DEX"],
    resistAll: ["Strike Resist", "Range Resist", "Tech Resist", "Fire Resist", "Ice Resist", "Lightning Resist", "Wind Resist", "Light Resist", "Dark Resist"],
	//regParam: new RegExp("([^\\(]+)\\(([\\+\\-]\\d+)\\)"),
    optionStore1: Ext.create("Ext.data.Store", {
        fields: ["id", "name", "value", "fn"],
        data: {}
    }),
    initOption1Value: "A01",
    optionStore2: Ext.create("Ext.data.Store", {
        fields: ["id", "name", "value", "extend", "effect"],
        data: {}
    }),
    excludePattern: [],
    initOption2Value: "B01",
    optionStore3: Ext.create("Ext.data.Store", {
        fields: ["id", "name", "value", "fn"],
        data: {}
    }),
    initOption3Value: "C01",
    totalValue: 0,
    sameBonusText: "Same",
    sameBonusBoost: [1, 1.1, 1.15],
    calcSameBonus: function(rateMap, sameCount) {
        var resultPanel = this;
        return Math.min(parseInt(rateMap.success * resultPanel.sameBonusBoost[PSO2.utils.overflow(resultPanel.sameBonusBoost.length, sameCount + 1, 1)]), 100)
    },
    initComponent: function() {
        var resultPanel = this;
        resultPanel.abilitySet = Ext.create("PSO2.AbilitySet", {
            abilityComponent: resultPanel.abilityComponent,
            abilityStore: resultPanel.abilityComponent.getAbilityStore()
        });
        if (resultPanel.supportData) {
            resultPanel.optionStore1.loadData(resultPanel.supportData)
        }
        if (resultPanel.additionalData) {
            resultPanel.optionStore2.loadData(resultPanel.additionalData)
        }
        if (resultPanel.potentialData) {
            resultPanel.optionStore3.loadData(resultPanel.potentialData)
        }
        this.addEvents("opt1change", "opt2change", "opt3change", "dodochange", "successchange");
        resultPanel.callParent(arguments)
    },
    initItems: function() {
        var resultPanel = this;
        resultPanel.resultItems = [];
        resultPanel.optionItems = [];
        resultPanel.successStore = Ext.create("Ext.data.ArrayStore", {
            autoDestroy: true,
            storeId: resultPanel.id + "-store",
            idIndex: 0,
            fields: [{
                name: "name",
                type: "string"
            }, {
                name: "success",
                type: "numeric"
            }]
        });
        resultPanel.viewPanel = Ext.create("Ext.view.View", {
            autoWidth: true,
            autoHeight: true,
            store: resultPanel.successStore,
            tpl: ['<table style="width:100%">', '<tpl for=".">', '<tr id="success">', '<td style="width:50%;padding-bottom:5px">{name}</td>', '<td style="width:50%;padding-bottom:5px">{success}%</td>', "</tr>", "</tpl>", "</table>", '<div style="clear:both"></div>'],
            itemSelector: "tr#success"
        });
        resultPanel.selOpt1 = resultPanel.createComboBox(resultPanel.constSelOption1, resultPanel.optionStore1, resultPanel.initOption1Value, "opt1change");
        resultPanel.selOpt2 = resultPanel.createComboBox(resultPanel.constSelOption2, resultPanel.optionStore2, resultPanel.initOption2Value, "opt2change", function(comboBox) {
            if (comboBox.value == null || comboBox.originalValue == comboBox.value) {
                this.optionItems = []
            } else {
                this.optionItems = [this.getSelectOptionRecord(comboBox)]
            }
        });
        resultPanel.selOpt3 = resultPanel.createComboBox(resultPanel.constSelOption3, resultPanel.optionStore3, resultPanel.initOption3Value, "opt3change");
        var checkboxID = resultPanel.id + resultPanel.constChkOption1;
        resultPanel.chkOpt1 = Ext.create("Ext.form.Checkbox", {
            id: checkboxID,
            labelWidth: 38,
            fieldLabel: resultPanel.sameBonusText,
            getSameCount: function() {
                if (!this.checked) {
                    return 0
                }
                var abSet = resultPanel.abilitySet,
                    numStore = abSet.stores.length,
                    index, count = 0;
                for (index = 0; index < numStore; index++) {
                    count += abSet.stores[index].exist() ? 1 : 0
                }
                return Math.max(0, count - 1)
            },
            listeners: {
                scope: resultPanel,
                change: function(e, f, c, d) {
                    this.refresh()
                }
            }
        });
        resultPanel.successPanel = Ext.create("Ext.panel.Panel", {
            id: resultPanel.id + resultPanel.constSuccessPanel,
            xtype: "panel",
            html: resultPanel.emptyText,
            style: {
                textAlign: "right"
            },
            padding: "0 0 5 0",
            anchor: "100%"
        });
        resultPanel.dodoButton = Ext.create("Ext.button.Button", {
            xtype: "button",
            text: resultPanel.dodoButtonText,
            anchor: "70%",
            disabled: true,
            scope: resultPanel,
            handler: resultPanel.onClickDoDo
        });
        resultPanel.patternButton = Ext.create("Ext.button.Button", {
            xtype: "button",
            text: resultPanel.monimoniButtonText,
            anchor: "30%",
            disabled: true,
            scope: resultPanel,
            handler: resultPanel.onClickPattern
        });
        resultPanel.items = [resultPanel.viewPanel, resultPanel.selOpt1, resultPanel.selOpt2, resultPanel.selOpt3, resultPanel.chkOpt1, resultPanel.successPanel, resultPanel.dodoButton, resultPanel.patternButton];
        resultPanel.prefixOptions = resultPanel.prefixOptions || {};
        resultPanel.prefixOptions[resultPanel.initOption1Value.charAt(0)] = resultPanel.selOpt1;
        resultPanel.prefixOptions[resultPanel.initOption2Value.charAt(0)] = resultPanel.selOpt2;
        resultPanel.prefixOptions[resultPanel.initOption3Value.charAt(0)] = resultPanel.selOpt3;
        resultPanel.callParent(arguments)
    },
    createComboBox: function(comboBoxID, optStore, initValue, event, func) {
        var resultPanel = this;
        return Ext.create("Ext.form.field.ComboBox", {
            id: resultPanel.id + comboBoxID,
            store: optStore,
            displayField: "id",
            forceSelection: true,
            editable: false,
            queryMode: "local",
            valueField: "value",
            value: initValue,
            typeAhead: true,
            anchor: "100%",
            disabled: true,
            listeners: {
                scope: resultPanel,
                change: function(comboBox, menuItem) {
                    if (Ext.isFunction(func)) {
                        func.call(this, comboBox)
                    }
                    if (menuItem !== true) {
                        this.refresh();
                        this.fireEvent(event, this, comboBox, comboBox.originalValue == comboBox.value)
                    }
                }
            }
        })
    },
    bindStore: function(store) {
        var resultPanel = this;
        return resultPanel.abilitySet.putStore(store)
    },
    // Get the object of the current option selected in the drop down menu
    getSelectOptionRecord: function(comboBox) {
        return comboBox.findRecord("value", comboBox.getValue())
    },
    // Set drop down menu to item
    selectOption: function(ddItem) {
        var resultPanel = this,
            comboBox = resultPanel.prefixOptions[ddItem.charAt(0)];
        if (comboBox) {
            comboBox.select(ddItem)
        }
    },
    refresh: function() {
        var resultPanel = this,
            dataView = resultPanel.viewPanel,
            successPanel = resultPanel.successPanel,
            // Functions of the options selected in the menu (refer to json)
            itemBoostFn = resultPanel.getSelectOptionRecord(resultPanel.selOpt1).get("fn"),
            potBoostFn = resultPanel.getSelectOptionRecord(resultPanel.selOpt3).get("fn"),
            sameItemCount = resultPanel.chkOpt1.getSameCount(),
            itemCount, overallRate = 100,
            m = [],
            successRate;
        resultPanel.successStore.loadData(m);
        resultPanel.successItems = resultPanel.abilityComponent.getSuccessList(resultPanel.abilitySet, resultPanel.resultItems, resultPanel.optionItems);
        for (itemCount = 0; itemCount < resultPanel.successItems.length; itemCount++) {
            successRate = resultPanel.calcSameBonus(resultPanel.successItems[itemCount], sameItemCount);
            successRate = itemBoostFn(successRate);
            successRate = potBoostFn(successRate);
            if (resultPanel.boostFunction) {
                successRate = resultPanel.boostFunction(successRate)
            }
            if (resultPanel.boostDayFunction) {
                successRate = resultPanel.boostDayFunction(successRate, resultPanel.successItems[itemCount].name)
            }
            m.push([resultPanel.successItems[itemCount]["name"], successRate]);
            overallRate *= successRate
        }
        if (0 < m.length) {
            resultPanel.successStore.loadData(m)
        }
        var prevTotalRate = resultPanel.totalValue;
        if (resultPanel.successItems.length == 0) {
            resultPanel.totalValue = 0;
            successPanel.update(resultPanel.emptyText)
        } else {
            resultPanel.totalValue = overallRate / Math.pow(100, itemCount);
            successPanel.update(resultPanel.totalValue + "%")
        }
        resultPanel.enableDoDoButton();
        resultPanel.enableOptionsSelect();
        if (prevTotalRate != resultPanel.totalValue) {
            resultPanel.fireEvent("successchange", resultPanel, resultPanel.totalValue, prevTotalRate)
        }
    },
    // Returns true if there is at least 1 material and at least 1 affix is selected
    isDodo: function() {
        var resultPanel = this;
        return (0 < resultPanel.abilitySet.enableMaterialMaxCount() && 1 <= resultPanel.abilityCount())
    },
    enableDoDoButton: function() {
        var resultPanel = this,
            duduButton = resultPanel.dodoButton,
            detailButton = resultPanel.patternButton,
            isDuduDisable = duduButton.isDisabled();
        if (resultPanel.isDodo()) {
            duduButton.enable();
            detailButton.enable();
            if (isDuduDisable) {
                resultPanel.fireEvent("dodochange", resultPanel, true, false)
            }
        } else {
            duduButton.disable();
            detailButton.disable();
            if (!isDuduDisable) {
                resultPanel.fireEvent("dodochange", resultPanel, false, true)
            }
        }
    },
    // Return the number of affixes selected (selected + added via items)
    abilityCount: function() {
        var resultPanel = this;
        return resultPanel.resultItems.length + resultPanel.optionItems.length
    },
    enableOptionsSelect: function() {
        var resultPanel = this;
        // Enable success boosters and zenesis if at least 1 affix, else resset and disable
        if (0 < resultPanel.abilityCount()) {
            resultPanel.selOpt1.enable();
            resultPanel.selOpt3.enable()
        } else {
            resultPanel.selOpt1.select(resultPanel.optionStore1.getAt(0));
            resultPanel.selOpt1.disable();
            resultPanel.selOpt3.select(resultPanel.optionStore3.getAt(0));
            resultPanel.selOpt3.disable()
        }
        // If there is less affix than max, allow add item
        if (resultPanel.resultItems.length < resultPanel.abilitySet.enableMaterialMaxCount()) {
            resultPanel.selOpt2.enable()
        } else {
            resultPanel.selOpt2.disable()
        }
    },
    // Removes all affixes from result panel and reset add item option
    removeAll: function() {
        var resultPanel = this;
        resultPanel.resultItems = [];
        resultPanel.abilitySet.resetAbility();
        resultPanel.selOpt2.select(resultPanel.optionStore2.getAt(0))
    },
    updateResults: function(selectionPanel) {
        var resultPanel = this,
            affixList = [],
            rateMap;
        if (!selectionPanel.rendered) {
            return false
        }
        selectionPanel.removeAll(true);
        resultPanel.removeAll();
        resultPanel.abilitySet.forEach(function(affixEntry, isSAF) {
            if (isSAF !== true) {
                affixList.push(affixEntry)
            }
        }, resultPanel);
        rateMap = resultPanel.abilityComponent.getSuccessList2(resultPanel.abilitySet, affixList);
        resultPanel.abilitySet.forEach(function(affixEntry, isSAF) {
            if (isSAF) {
                selectionPanel.add({
                    fieldStyle: "float:left",
                    boxLabel: '<p class="x-factor-icon" style="float:left;margin-left:2px;padding-left:16px">' + affixEntry.name + '</p><p style="float:right;padding-right:3px">100%</p>',
                    inputValue: "*" + affixEntry.code,
                    abilityData: affixEntry,
                    resultPanel: resultPanel,
                    fieldSet: selectionPanel
                })
            } else {
                // If rate is not 0, add to selection list
                if (rateMap[affixEntry.code]) {
                    selectionPanel.add({
                        fieldStyle: "float:left",
                        boxLabel: '<p style="float:left;padding-left:3px">' + affixEntry.name + '</p><p style="float:right;padding-right:3px">' + rateMap[affixEntry.code] + "%</p>",
                        inputValue: affixEntry.code,
                        abilityData: affixEntry,
                        resultPanel: resultPanel,
                        fieldSet: selectionPanel
                    })
                }
            }
        }, resultPanel);
        resultPanel.refresh()
    },
    // Get max amount of affix can be selected
    getEnableMaxCount: function() {
        return this.abilitySet.enableMaterialMaxCount()
    },
    // Get all affixes selected from the selection panel
    getValues: function() {
        var resultPanel = this,
            a = [];
        Ext.Array.forEach(resultPanel.resultItems, function(c) {
            a.push(c.inputValue)
        });
        return a
    },
    // Returns true if two affix codes are excluded from each other, false otherwise
    isExcludePattern: function(code1, code2) {
        var resultPanel = this,
            allExclude = Ext.isArray(resultPanel.excludePattern) ? resultPanel.excludePattern : [resultPanel.excludePattern];
        var exPatternLen = allExclude.length,
            isCode1SAF = code1.substr(0, 1) == "*",
            isCode2SAF = code2.substr(0, 1) == "*",
            codeHeader1 = isCode1SAF ? code1.substr(1, 2) : code1.substr(0, 2),
            codeHeader2 = isCode2SAF ? code2.substr(1, 2) : code2.substr(0, 2),
            regex = /([^\*]+)\*$/,
            resRegex, headMatch = function(excludePattern, codeHeader) {
                if (resRegex = excludePattern.match(regex)) {
                    return excludePattern.substr(0, resRegex[1].length) == codeHeader.substr(0, resRegex[1].length)
                }
                return excludePattern == codeHeader
            };
        // Trigger by SAF
        if (codeHeader1 == codeHeader2) {
            return true
        }
        for (var e = 0; e < exPatternLen; e++) {
            var excludePattern = allExclude[e],
                firstMatch = false;
            excludePattern = Ext.isArray(excludePattern) ? excludePattern : [excludePattern];
            for (var index = 0; index < excludePattern.length; index++) {
                firstMatch = headMatch(excludePattern[index], codeHeader1);
                if (firstMatch) {
                    break
                }
            }
            if (firstMatch) {
                for (var index = 0; index < excludePattern.length; index++) {
                    if (headMatch(excludePattern[index], codeHeader2)) {
                        return true
                    }
                }
            }
        }
        return false
    },
    // Adds affix the result page, returns count
    addAbility: function(selAffix, needRefresh) {
        var resultPanel = this,
            removeList = [],
            resItemLen = resultPanel.resultItems.length;
        for (var index = 0; index < resItemLen; index++) {
            if (resultPanel.isExcludePattern(selAffix.inputValue, resultPanel.resultItems[index].inputValue)) {
                removeList.push(resultPanel.resultItems[index])
            }
        }
        for (var index = 0; index < removeList.length; index++) {
            removeList[index].setValue(false)
        }
        resultPanel.resultItems.push(selAffix);
        if (needRefresh !== true) {
            resultPanel.refresh()
        }
        return resultPanel.abilityCount()
    },
    removeAbility: function(deselAffix, needRefresh) {
        var resultPanel = this,
            b = Ext.Array.indexOf(resultPanel.resultItems, deselAffix);
        if (0 <= b) {
            resultPanel.resultItems.splice(b, 1);
            if (needRefresh !== true) {
                resultPanel.refresh()
            }
        }
        return resultPanel.abilityCount()
    },
    // The Dudu button. Return true is all affix pass, else false. Array pass in are modified
    doDo: function(success, fail) {
        var resultPanel = this,
            itemBoostFn = resultPanel.getSelectOptionRecord(resultPanel.selOpt1).get("fn"),
            potBoostFn = resultPanel.getSelectOptionRecord(resultPanel.selOpt3).get("fn"),
            sameItemCount = resultPanel.chkOpt1.getSameCount(),
            selAffixList = resultPanel.successItems,
            selAffixLen = selAffixList.length,
            affixRate;
        if (0 < selAffixLen) {
            for (var index = 0; index < selAffixLen; index++) {
                affixRate = resultPanel.calcSameBonus(selAffixList[index], sameItemCount);
                affixRate = itemBoostFn(affixRate);
                affixRate = potBoostFn(affixRate);
                if (resultPanel.boostFunction) {
                    affixRate = resultPanel.boostFunction(affixRate)
                }
                if (resultPanel.boostDayFunction) {
                    affixRate = resultPanel.boostDayFunction(affixRate, selAffixList[index].name)
                }
                if (100 <= affixRate || Math.floor(Math.random() * 100) < affixRate) {
                    success.push({
                        fieldLabel: selAffixList[index].name,
                        name: (resultPanel.id + "-" + index),
                        value: affixRate + "%"
                    })
                } else {
                    fail.push({
                        fieldLabel: selAffixList[index].name,
                        name: (resultPanel.id + "-" + index),
                        value: affixRate + "%"
                    })
                }
            }
        }
        return (0 < success.length) && (fail.length == 0)
    },
    // Calculate how many complete success over total attempt
    getTotalSuccess: function(totalSuccess, noTotalSuccess) {
        var a = "Total: " + totalSuccess + " / " + (totalSuccess + noTotalSuccess) + " = ";
        if (totalSuccess == 0) {
            a += "0%"
        } else {
            a += Ext.util.Format.number((totalSuccess / (totalSuccess + noTotalSuccess)) * 100, "0.000") + "%"
        }
        return a
    },
    // Use for calculate cost feature, returns what items are being used
    selectedOptions: function() {
        var resultPanel = this;
        return [resultPanel.selOpt1.value, resultPanel.selOpt2.value, resultPanel.selOpt3.value]
    },
    onClickDoDo: function() {
        var resultPanel = this;
        if (0 < resultPanel.items.length) {
            var fail = [],
                success = [],
                isCompleteSuccess = resultPanel.doDo(fail, success);
            resultPanel.win = Ext.create("widget.window", {
                title: "Synthesis Results",
                autoDestroy: true,
                closable: true,
                closeAction: "destroy",
                width: resultPanel.noDD === true ? Ext.getBody().getWidth() : Math.min(Ext.getBody().getWidth(), 600),
                height: 148 + (fail.length + success.length) * 26,
                modal: true,
                successNum: isCompleteSuccess ? 1 : 0,
                failNum: isCompleteSuccess ? 0 : 1,
                layout: "anchor",
                bodyStyle: "padding: 5px;",
                defaults: {
                    anchor: "100%"
                },
                items: [{
                    xtype: "fieldset",
                    frame: true,
                    title: "Addition Successful",
                    margins: "0 5 0 5",
                    layout: "anchor",
                    autoHeight: true,
                    defaultType: "textfield",
                    defaults: {
                        readOnly: true,
                        labelWidth: resultPanel.noDD === true ? (Ext.getBody().getWidth() / 2) : 140,
                        anchor: "100%"
                    },
                    items: fail
                }, {
                    xtype: "fieldset",
                    frame: true,
                    title: "Addition Failed",
                    margins: "0 5 0 5",
                    layout: "anchor",
                    autoHeight: true,
                    defaultType: "textfield",
                    defaults: {
                        readOnly: true,
                        labelWidth: resultPanel.noDD === true ? (Ext.getBody().getWidth() / 2) : 140,
                        anchor: "100%"
                    },
                    items: success
                }],
                dockedItems: [{
                    xtype: "toolbar",
                    ui: "footer",
                    dock: "bottom",
                    items: [{
                        xtype: "label",
                        readOnly: true,
                        textAlign: "right",
                        html: resultPanel.getTotalSuccess(isCompleteSuccess ? 1 : 0, isCompleteSuccess ? 0 : 1),
                        bodyStyle: {
                            "float": "hidden"
                        }
                    }, "->", Ext.create("Ext.button.Button", {
                        text: resultPanel.redodoButtonText,
                        scope: resultPanel,
                        handler: function() {
                            var success = [],
                                fail = [],
                                fieldset = this.win.query("fieldset"),
                                totalLabel = this.win.query("toolbar")[0].query("label");
                            if (this.doDo(success, fail)) {
                                this.win.successNum++
                            } else {
                                this.win.failNum++
                            }
                            fieldset[0].removeAll();
                            fieldset[0].add(success);
                            fieldset[1].removeAll();
                            fieldset[1].add(fail);
                            totalLabel[0].update(this.getTotalSuccess(this.win.successNum, this.win.failNum))
                        },
                        minWidth: 64
                    }), Ext.create("Ext.button.Button", {
                        text: resultPanel.moreButtonText,
                        scope: resultPanel,
                        handler: function() {
                            var success = [],
                                fail = [],
                                fieldset = this.win.query("fieldset"),
                                totalLabel = this.win.query("toolbar")[0].query("label"),
                                count = this.moreDodoLimit;
                            while (!this.doDo(success, fail) && count--) {
                                this.win.failNum++;
                                success = [];
                                fail = []
                            }
                            if (fail.length == 0) {
                                this.win.successNum++
                            }
                            fieldset[0].removeAll();
                            fieldset[0].add(success);
                            fieldset[1].removeAll();
                            fieldset[1].add(fail);
                            totalLabel[0].update(this.getTotalSuccess(this.win.successNum, this.win.failNum))
                        },
                        minWidth: 64
                    }), Ext.create("Ext.button.Button", {
                        text: "Close",
                        scope: resultPanel,
                        handler: function() {
                            if (this.win) {
                                this.win.close()
                            }
                            delete this.win;
                            this.win = null
                        },
                        minWidth: 64
                    })]
                }]
            }).show()
        }
    },
    // Count the number of bits - 1
    popCnt: function(numFail) {
        numFail >>>= 0;
        for (var a = 0; numFail; numFail &= numFail - 1) {
            a++
        }
        return a
    },
    // Calculate the probability of complete success (in decimal)
    probability: function(rateArray) {
        var len = rateArray.length,
            totalRate = 1;
        for (var c = 0; c < len; c++) {
            totalRate *= rateArray[c]
        }
        return totalRate / Math.pow(100, len)
    },
    // Calculate the total chance of a scenario
    addition: function(chance) {
        var len = chance.length,
            c = 0;
        for (var b = 0; b < len; b++) {
            c += chance[b]
        }
        return c
    },
    // Returns the overall success rate when numFail affixes failed
    getSuccessPattern: function(numFail, rateList, itemBoostFn) {
        var resultPanel = this,
            rateLen = rateList.length,
            possibleSet = 1 << rateLen,
            allScenario = [];
        for (var set = 0; set < possibleSet; set++) {
            if (numFail == resultPanel.popCnt(set)) {
                var scenario = [];
                for (var index = 0; index < rateLen; index++) {
                    if (set & (1 << index)) {
                        // Fail
                        scenario.push(100 - itemBoostFn(rateList[index]))
                    } else {
                        // Success
                        scenario.push(itemBoostFn(rateList[index]))
                    }
                }
                allScenario.push(resultPanel.probability(scenario))
            }
        }
        return resultPanel.addition(allScenario)
    },
    // Calculate the total stats boost from all the affixes and store in the array
    addAbilityParameter: function(overallStat, stat, value) {
        var resultPanel = this;
        if (stat == "ALL") {
            for (var b = 0; b < resultPanel.allUp.length; b++) {
                resultPanel.addAbilityParameter(overallStat, resultPanel.allUp[b], value)
            }
        } else {
            if (stat == "All Resist") {
                for (var b = 0; b < resultPanel.resistAll.length; b++) {
                    resultPanel.addAbilityParameter(overallStat, resultPanel.resistAll[b], value)
                }
            } else {
                if (!overallStat[stat]) {
                    overallStat[stat] = 0
                }
                overallStat[stat] += value
            }
        }
    },
    // onClick 'Details" button
    onClickPattern: function() {
        var resultPanel = this;
        if (0 < resultPanel.items.length) {
            var affixList = resultPanel.successItems, // Contains name & success rate
                tabs = [],
                col = [],
                colHead = [];
            tabs.push(resultPanel.getSpecInfo(affixList));
            tabs.push(resultPanel.getSuccessTable(affixList, col, colHead));
            tabs.push(resultPanel.getSuccessGraph(affixList, col, colHead));
            tabs.push(resultPanel.getOrderView(affixList));
            resultPanel.win = Ext.create("widget.window", {
                title: "Data Monitor",
                autoDestroy: true,
                closable: true,
                closeAction: "destroy",
                width: resultPanel.noDD === true ? Ext.getBody().getWidth() : 600,
                autoHeight: true,
                modal: true,
                layout: "fit",
                bodyStyle: "padding: 5px;",
                items: Ext.createWidget("tabpanel", {
                    activeTab: 0,
                    defaults: {
                        bodyPadding: 5
                    },
                    items: tabs
                }),
                dockedItems: [{
                    xtype: "toolbar",
                    ui: "footer",
                    dock: "bottom",
                    items: ["->", Ext.create("Ext.button.Button", {
                        text: "Close",
                        scope: resultPanel,
                        handler: function() {
                            if (this.win) {
                                this.win.close()
                            }
                            delete this.win;
                            this.win = null
                        },
                        minWidth: 105
                    })]
                }]
            }).show()
        }
    },
    // Produce stats table
    getSpecInfo: function(abilityList) {
        var resultPanel = this,
            abStore = resultPanel.abilitySet.abilityStore,
            abilityEntry, abilityEffect, affixBreakdown, overallStat = {},
            text = [],
            regex = new RegExp("([^\\(]+)\\(([\\+\\-]\\d+)\\)"),
            abilityListLen = abilityList.length,
            outputText = "";
        for (var index = 0; index < abilityListLen; index++) {
            abilityEntry = abStore.findRecord("name", abilityList[index].name) || resultPanel.optionStore2.findRecord("name", abilityList[index].name);
            abilityEffect = abilityEntry.get("effect").replace(/<br>/g, ",").split(",");
            for (j = 0; j < abilityEffect.length; j++) {
                affixBreakdown = abilityEffect[j].match(regex);
                if (affixBreakdown && affixBreakdown.length == 3) {
                    resultPanel.addAbilityParameter(overallStat, affixBreakdown[1], parseInt(affixBreakdown[2]))
                } else {
                    if (affixBreakdown === null) {
                        text.push(abilityEffect[j])
                    }
                }
            }
        }
        // Output stat info
        for (var index = 0; index < resultPanel.abText.length; index++) {
            if (overallStat[resultPanel.abText[index]]) {
                if (0 < overallStat[resultPanel.abText[index]]) {
                    outputText += "<div>" + resultPanel.abText[index] + '<span style="color:red;font-weight:bold">&nbsp;&nbsp;(+' + Math.abs(overallStat[resultPanel.abText[index]]) + ")</span></div>"
                } else {
                    outputText += "<div>" + resultPanel.abText[index] + '<span style="color:blue;font-weight:bold">&nbsp;&nbsp;(-' + Math.abs(overallStat[resultPanel.abText[index]]) + ")</span></div>"
                }
            }
        }
        // Output text info
        for (var index = 0; index < text.length; index++) {
            outputText += "<div>" + text[index] + "</div>"
        }
        return {
            title: "Abilities",
            html: outputText
        }
    },
    // Produce table of the success rate in the details tab
    getSuccessTable: function(abilityListLen, col, colHead) {
        var resultPanel = this,
            rateList = [],
            potBoostFn = resultPanel.getSelectOptionRecord(resultPanel.selOpt3).get("fn"),
            len = abilityListLen.length,
            optItem1List = resultPanel.selOpt1.store,
            opt1Len = optItem1List.count(),
            rate;
        for (var index = 0; index < len; index++) {
            rate = resultPanel.calcSameBonus(abilityListLen[index], resultPanel.chkOpt1.getSameCount());
            rate = potBoostFn(rate);
            if (resultPanel.boostFunction) {
                rate = resultPanel.boostFunction(rate)
            }
            if (resultPanel.boostDayFunction) {
                rate = resultPanel.boostDayFunction(rate, abilityListLen[index].name)
            }
            rateList.push(rate)
        }
        var tableHtml = '<table id="ps"><tr><td id="psh"></td>';
        for (var index = 0; index < opt1Len; index++) {
            rec = optItem1List.getAt(index);
            tableHtml += '<td id="psh" style="width:' + parseInt(88 / opt1Len) + '%">' + rec.get("name") + "</td>"
        }
        tableHtml += "</tr>";
        var rowHeader;
        for (var index = 0; index <= len; index++) {
            if (index == 0) {
                rowHeader = "Success"
            } else {
                if (index == len) {
                    rowHeader = "Complete Failure"
                } else {
                    rowHeader = index + "Failure(s)"
                }
            }
            tableHtml += '<tr><td id="ps">' + rowHeader + "</td>";
            colHead.push(rowHeader);
            for (j = 0; j < opt1Len; j++) {
                var scenarioRate = resultPanel.getSuccessPattern(index, rateList, optItem1List.getAt(j).get("fn"));
                tableHtml += "<td";
                if (scenarioRate == 1) {
                    tableHtml += ' id="bold"'
                } else {
                    if (0.8 < scenarioRate) {
                        tableHtml += ' id="high"'
                    } else {
                        if (scenarioRate < 0.1) {
                            tableHtml += ' id="low"'
                        }
                    }
                }
                tableHtml += ">" + Ext.util.Format.number(scenarioRate * 100, "0.000") + "%</td>";
                col[j] = col[j] || {};
                if (index == 0) {
                    col[j]["name"] = optItem1List.getAt(j).get("name")
                }
                col[j][rowHeader] = scenarioRate * 100
            }
            tableHtml += "</tr>"
        }
        tableHtml += "</table>";
        return {
            title: "Success Rate Pattern",
            html: tableHtml
        }
    },
    // Produce success graph in the detail tab
    getSuccessGraph: function(abilityList, col, colHead) {
        var len = abilityList.length;
        return {
            xtype: "chart",
            title: "Success Rate Graph",
            height: 160 + 24 * len,
            style: "background:#fff",
            animate: true,
            theme: "Browser:gradients",
            defaultInsets: 30,
            store: Ext.create("Ext.data.JsonStore", {
                fields: colHead,
                data: col
            }),
            legend: {
                position: "right"
            },
            axes: [{
                type: "Numeric",
                position: "left",
                fields: colHead,
                title: "Lost %",
                grid: true,
                decimals: 0,
                minimum: 0,
                maximum: 100
            }, {
                type: "Category",
                position: "bottom",
                fields: ["name"],
                title: "Usage"
            }],
            series: [{
                type: "area",
                axis: "left",
                highlight: true,
                tips: {
                    trackMouse: true,
                    width: 170,
                    height: 28,
                    renderer: function(colData, point) {
                        this.setTitle(point.storeField + " - " + Ext.util.Format.number(colData.get(point.storeField), "0.000") + "%")
                    }
                },
                xField: "name",
                yField: colHead,
                style: {
                    lineWidth: 1,
                    stroke: "#666",
                    opacity: 0.86
                }
            }]
        }
    },
    // Produce the order view tab. 
    // Display how the affix would look like base on selection order
    getOrderView: function(abilityList) {
        var resultPanel = this,
            len = abilityList.length,
            htmlAffixList = [],
            fieldset;
        for (var index = 0; index < len; index++) {
            htmlAffixList.push({
                html: abilityList[index]["name"]
            })
        }
        fieldset = Ext.create("Ext.form.FieldSet", {
            frame: true,
            title: "Special Abilities",
            margins: "0",
            width: "100%",
            layout: "column",
            autoHeight: true,
            defaults: {
                columnWidth: 0.5,
                border: 0,
                margin: "5 0 10 0",
                cls: "x-order-ability"
            },
            viewLimit: -1,
            viewAbility: false,
            stackAbility: [],
            capacityOver: false,
            items: htmlAffixList,
            getCount: function() {
                return this.items.length + this.stackAbility.length
            }
        });
        return {
            xtype: "panel",
            title: "Order",
            layout: "column",
            items: [{
                xtype: "checkbox",
                boxLabel: "Potential/Timed Ability",
                fs: fieldset,
                listeners: {
                    scope: resultPanel,
                    change: function(comboBox, curOpt, prevOpt, resultPanel) {
                        fieldset.viewAbility = curOpt;
                        resultPanel.updateOrderView(fieldset, curOpt != prevOpt)
                    }
                }
            }, Ext.create("Ext.form.field.ComboBox", {
                fs: fieldset,
                style: "marginLeft: 15px",
                store: Ext.create("Ext.data.ArrayStore", {
                    autoDestroy: true,
                    fields: [{
                        name: "id",
                        type: "numeric"
                    }, {
                        name: "name",
                        type: "string"
                    }],
                    data: [
                        [-1, "Default"],
                        [6, "6 Slots"],
                        [8, "8 Slots"]
                    ]
                }),
                displayField: "name",
                forceSelection: true,
                editable: false,
                queryMode: "local",
                valueField: "id",
                value: fieldset.viewLimit,
                typeAhead: true,
                anchor: "100%",
                listeners: {
                    scope: resultPanel,
                    change: function(checkBox, curIsCheck, g, resultPanel) {
                        fieldset.viewLimit = curIsCheck;
                        resultPanel.updateOrderView(fieldset, false)
                    }
                }
            }), fieldset]
        }
    },
    // Update order display when comboBox change and/or timed ability is select
    updateOrderView: function(fieldset, showTimed) {
        var b = fieldset.getCount();
        if (showTimed) {
            if (fieldset.viewAbility) {
                fieldset.insert(0, {
                    html: "Potential/Timed Ability",
                    cls: "x-order-with-ability"
                })
            } else {
                fieldset.remove(fieldset.items.getAt(0))
            }
        }
        if (fieldset.capacityOver) {
            fieldset.remove(fieldset.items.getAt(fieldset.items.length - 1));
            for (; 0 < fieldset.stackAbility.length;) {
                fieldset.add(fieldset.stackAbility.pop())
            }
        }
        if (fieldset.viewLimit != -1) {
            if (fieldset.viewLimit < fieldset.getCount()) {
                for (; fieldset.viewLimit <= fieldset.items.length;) {
                    var fieldsetItem = fieldset.items.getAt(fieldset.items.length - 1);
                    fieldset.stackAbility.push({
                        html: fieldsetItem.el.dom.textContent
                    });
                    fieldset.remove(fieldsetItem)
                }
            } else {
                for (; fieldset.items.length <= fieldset.viewLimit && 0 < fieldset.stackAbility.length;) {
                    fieldset.add(fieldset.stackAbility.pop())
                }
            }
        }
        if (0 < fieldset.stackAbility.length) {
            fieldset.add({
                html: "…and " + fieldset.stackAbility.length + " others"
            });
            fieldset.capacityOver = true
        } else {
            fieldset.capacityOver = false
        }
    }
});
Ext.ns("PSO2");
Ext.override(Ext.data.Record, {
    isModified: function(fieldname) {
        return false
    }
});
Ext.override(Ext.grid.header.Container, {
    sortAscText: "Ascending",
    sortDescText: "Descending",
    sortClearText: "Clear",
    columnsText: "Columns"
});
Ext.override(Ext.tab.Tab, {
    closeText: "Close Tab"
});
Ext.define("PSO2.TabCloseMenu", {
    extend: "Ext.tab.TabCloseMenu",
    closeTabText: "Close this tab",
    closeText: "Close this tab",
    closeOthersTabsText: "Close other tabs",
    closeAllTabsText: "Close all tabs",
    onAfterLayout: function() {
        var contextMenuDetails = {
            scope: this,
            delegate: "div.x-tab"
        }; // Only seems to trigger when on mobile device
        contextMenuDetails[this.menuTrigger] = function(event, tab) {
            var b = this;
            if (b.tabBar.getChildByElement(tab)) {
                b.onContextMenu(event, tab)
            }
        };
        this.mon(this.tabBar.el, contextMenuDetails)
    }
});
Ext.define("PSO2.GridGrouping", {
    extend: "Ext.grid.feature.Grouping",
    enableGroupingMenu: false,
    startCollapsed: true,
    groupHeaderTpl: "{[this.getHeaderName(values)]}",
    getFragmentTpl: function() {
        return Ext.apply(this.callParent(arguments) || {}, {
            getHeaderName: this.getHeaderName
        })
    },
    getHeaderName: function(affixGroup) {
        if (affixGroup.name == "AA") {
            return "Stat Enhancement"
        } else if (affixGroup.name == "AB") {
            return "Stat Enhancement (Lesser)"
        } else if (affixGroup.name == "AC") {
            return "Stat Enhancement (Special)"
        } else if (affixGroup.name == "CB") {
            return "Special Ability Factor"
        } else if (affixGroup.name == "DA") {
            return "Resistance"
        } else if (affixGroup.name == "DB") {
            return "Status Effect"
        } else if (affixGroup.name == "EA") {
            return "Soul"
        } else if (affixGroup.name == "EB") {
            return "Fever"
        } else if (affixGroup.name == "GB") {
            return "Receptors"
        } else if (affixGroup.name == "YA") {
            return "Special"
        } else if (affixGroup.name == "L1") {
            return "S-Class Special Abilities 1"
        } else if (affixGroup.name == "L2") {
            return "S-Class Special Abilities 2"
        } else if (affixGroup.name == "L3") {
            return "S-Class Special Abilities 3"
        } else if (affixGroup.name == "L4") {
            return "S-Class Special Abilities 4"
        }
        return "Other"
    }
});
Ext.define("PSO2.SynthesisComponent", {
    extend: "Ext.container.Container",
    version: "1.79E",
    title: "PSO2 Affix Simulator",
    constCookieName: "pso2dodo",
    outputViewport: false,
    limitUrlSize: 10,
    maxMaterial: 5,
    currentTabItem: null,
    selectedGridCell: null,
    boostCampaign: true,
    getRecommendRecipe: false,
    factorMenuText: {
        on: "Add Factor",
        off: "Cancel Factor"
    },
    constructor: function(params) {
        var synComp = this,
            viewportData, abCompData = {};
        Ext.apply(synComp, params);
        if (synComp.ajaxData) {
            if (synComp.ajaxData.abilityList) {
                abCompData.constAbility = synComp.ajaxData.abilityList
            }
            if (synComp.ajaxData.extraSlot) {
                abCompData.constExtra = synComp.ajaxData.extraSlot
            }
            if (synComp.ajaxData.boostPoint) {
                abCompData.constBoostPoint = synComp.ajaxData.boostPoint
            }
            if (synComp.ajaxData.extendAbility) {
                abCompData.constExtendAbility = synComp.ajaxData.extendAbility
            }
            if (synComp.ajaxData.boostdaySystem){
                abCompData.boostdaySystem = synComp.ajaxData.boostdaySystem
            }
        }
        synComp.ability = Ext.create("PSO2.AbilityComponent", abCompData);
        if (synComp.items) {
            if (!Ext.isArray(synComp.items)) {
                viewportData = [synComp.items]
            } else {
                viewportData = synComp.items
            }
            delete synComp.items
        } else {
            viewportData = []
        }
        viewportData.push({
            cls: "app-header",
            region: "north",
            height: 35,
            layout: "fit",
            hidden: synComp.noDD,
            html: ['<div class="x-top-title">', synComp.title + " ver " + synComp.version + "&nbsp;", '<span class="x-top-author">', '<a href="http://rxio.blog.fc2.com/" style="text-decoration:none">Created by Pulsar@倉庫絆</a>&nbsp;&amp;&nbsp;', '<a target="_blank" href="http://pso2numao.web.fc2.com/dodo/" style="text-decoration:none">助右衛門@ship8</a>',' | <a href="http://arks-layer.com/" style="text-decoration:none">English version maintained by Aida</a> (Updated 6-7-18)<br>Message Aida Enna#0001 on Discord or <a href="http://discord.gg/PSO2" style="text-decoration:none">join our Discord server</a> to report bugs/issues/suggestions.', "</span>", "</div>"].join("")
        });
        synComp.panelNames = ["Fodder"];
        for (var d = 1; d <= synComp.maxMaterial; d++) {
            synComp.panelNames.push("Fodder " + d)
        }
        // If not on iphone, android, ipod or ipad
        if (synComp.noDD !== true) {
            synComp.abilityGrid = Ext.create("Ext.grid.Panel", {
                title: "Special Ability",
                region: "west",
                collapsible: true,
                floatable: true,
                split: true,
                forceFit: true,
                sortableColumns: false,
                scroll: false,
                columns: [{
                    dataIndex: "name",
                    header: "Ability",
                    width: 108,
                    filterable: true,
                    filter: {
                        type: "string"
                    }
                }, {
                    dataIndex: "effect",
                    header: "Effect",
                    width: 144,
                    filter: {
                        type: "string"
                    },
                    // Tooltip for affix entry, giving details on affix boost
                    renderer: function(affixDetails, k, affixEntry) {
                        if (affixEntry.get("extup")) {
                            var l = [];
                            Ext.Array.forEach(affixEntry.get("extup"), function(m) {
                                var n = this.ability.findAbilityName(m.length == 2 ? m + "01" : m);
                                if (n) {
                                    l.push(m.length == 2 ? n.get("name").replace(/[IV]+$/, "").replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "") : n.get("name"))
                                }
                            }, synComp);
                            k.tdAttr = 'data-qtip="' + l.join(", ") + ' Affix Bonus'
                        }
                        if(affixEntry.get("tooltip") && !k.tdAttr)
                            k.tdAttr = 'data-qtip="' + affixEntry.get("tooltip")
                        else if(affixEntry.get("tooltip"))
                            k.tdAttr += "<br>" + affixEntry.get("tooltip")+'"'
                        
                        if(k.tdAttr)
                            k.tdAttr += '"'
                        return affixDetails
                    }
                }],
                features: [{
                    ftype: "filters",
                    encode: false,
                    local: true,
                    menuFilterText: "Search",
                    filters: [{
                        type: "string",
                        dataIndex: "name"
                    }, {
                        type: "string",
                        dataIndex: "effect"
                    }]
                }, Ext.create("PSO2.GridGrouping")],
                viewConfig: {
                    altRowCls: "x-grid-row-group",
                    style: {
                        overflow: "auto",
                        overflowX: "hidden"
                    },
                    listeners: {
                        render: synComp.initializeAbilityDragZone
                    },
                    // Color the row entries
                    doStripeRows: function(k, h) {
                        if (this.stripeRows) {
                            var listEntries = this.getNodes(k, h),
                                len = listEntries.length,
                                index = 0,
                                row, affixEntry, codeHead = "";
                            for (; index < len; index++) {
                                row = listEntries[index];
                                affixEntry = this.getRecord(row);
                                row.className = row.className.replace(this.rowClsRe, " ");
                                // Alternate between one color and other base on group
                                if (affixEntry.get("code").substring(0, 2) !== codeHead) {
                                    k++;
                                    codeHead = affixEntry.get("code").substring(0, 2)
                                }
                                if (k % 2 === 0) {
                                    row.className += (" " + this.altRowCls)
                                }
                                // If soul qualified for __ the Soul affix
                                if (affixEntry.get("cls")) {
                                    row.className += (" " + affixEntry.get("cls"))
                                }
                            }
                        }
                    }
                },
                store: synComp.ability.getAbilityStore()
            });
            viewportData.push(synComp.abilityGrid)
        } else { // on iphone, ipod, ipad, android
            synComp.abilityWindow = Ext.create("widget.window", {
                title: "Special Ability",
                autoDestroy: false,
                closable: true,
                closeAction: "hide",
                modal: true,
                bodyStyle: "padding:5px;",
                autoScroll: true,
                items: Ext.create("Ext.grid.Panel", {
                    store: synComp.ability.getAbilityStore(),
                    forceFit: true,
                    scroll: false,
                    columns: [{
                        dataIndex: "name",
                        header: "Ability",
                        filter: {
                            type: "string"
                        }
                    }, {
                        dataIndex: "effect",
                        header: "Effect",
                        filter: {
                            type: "string"
                        }
                    }],
                    viewConfig: {
                        style: {
                            overflow: "auto",
                            overflowX: "hidden"
                        },
                        listeners: {
                            scope: synComp,
                            cellclick: function(view, cell, colIdx, store, iRow, rowIdx, event) {
                                if (this.selectedGridCell) {
                                    this.selectedGridCell.view.getStore().addAbility(store.data)
                                }
                                this.selectedGridCell = null;
                                this.abilityWindow.hide()
                            }
                        }
                    }
                })
            })
        }
        synComp.tabPanel = Ext.createWidget("tabpanel", {
            resizeTabs: true,
            enableTabScroll: true,
            defaults: {
                autoScroll: true,
                bodyPadding: 1
            },
            plugins: Ext.create("PSO2.TabCloseMenu", {
                menuTrigger: (synComp.noDD ? "click" : "contextmenu"),
                extraItemsTail: ["-", {
                    text: "Fill with trash",
                    scope: synComp,
                    handler: function() {
                        var plugin = this.tabPanel.plugins[0],
                            tabIndex = this.findLocationHashBy(plugin.item);
                        if (0 <= tabIndex) {
                            this.tabPanel.items.getAt(tabIndex).fillDuster()
                        }
                    }
                }, {
                    text: "Copy",
                    scope: synComp,
                    handler: function() {
                        var plugin = this.tabPanel.plugins[0],
                            tabIndex = this.findLocationHashBy(plugin.item);
                        if (0 <= tabIndex) {
                            this.selectLoadData(null, this.locationHash[tabIndex])
                        }
                    }
                }],
                listeners: {
                    scope: synComp,
                    aftermenu: function() {
                        this.currentTabItem = null
                    }
                }
            }),
            listeners: {
                scope: synComp,
                beforeremove: function(h, g) {
                    if (g.$className != "PSO2.CostPanel") {
                        this.removeLocationHash(g)
                    }
                }
            }
        });
        // Add, Save, Load buttons
        var buttons = [Ext.create("Ext.Action", {
            iconCls: "x-add-icon",
            text: "Add Panel",
            scope: synComp,
            handler: function() {
                this.tabPanel.setActiveTab(this.addTab())
            }
        }), Ext.create("Ext.Action", {
            iconCls: "x-save-icon",
            text: "Save",
            scope: synComp,
            handler: synComp.saveData
        }), Ext.create("Ext.Action", {
            iconCls: "x-load-icon",
            text: "Load",
            scope: synComp,
            handler: synComp.loadData
        })];
        if (synComp.boostCampaign == true) {
            buttons.push("-");
            buttons.push(Ext.create("Ext.form.field.ComboBox", {
                store: Ext.create("Ext.data.JsonStore", {
                    autoLoad: false,
                    fields: ["T", "V", "F"],
                    data: [{
                        T: "No Boost",
                        V: 0,
                        F: null
                    }, {
                        T: "5% UP",
                        V: 5,
                        F: function(baseRate) {
                            return Math.min(baseRate + 5, 100)
                        }
                    }, {
                        T: "10% UP",
                        V: 10,
                        F: function(baseRate) {
                            return Math.min(baseRate + 10, 100)
                        }
                    }]
                }),
                displayField: "T",
                forceSelection: true,
                editable: false,
                queryMode: "local",
                valueField: "V",
                value: 0,
                typeAhead: true,
                width: 84,
                listeners: {
                    scope: synComp,
                    change: function(combobox, newValue, prevValue) {
                        var resultPanels = this.tabPanel.query("resultpanel");
                        this.enableBoost = (0 < newValue);
                        this.boostFunction = combobox.store.findRecord("V", newValue).get("F");
                        if (this.enableBoost) {
                            combobox.addCls("x-campaign-up")
                        } else {
                            combobox.removeCls("x-campaign-up")
                        }
                        if (Ext.isArray(resultPanels)) {
                            for (var k = 0; k < resultPanels.length; k++) {
                                resultPanels[k].boostFunction = this.boostFunction;
                                if (resultPanels[k].rendered) {
                                    resultPanels[k].refresh()
                                }
                            }
                        }
                    }
                }
            }))
        }
        if (synComp.boostCampaign == true) {
            buttons.push("-");
            buttons.push(Ext.create("Ext.form.field.ComboBox", {
                store: Ext.create("Ext.data.JsonStore", {
                    autoLoad: false,
                    fields: ["T", "V", "F"],
                    data: [{
                        T: "No Boost",
                        V: 0,
                        F: null
                    }, {
                        T: "5% Strike UP",
                        V: "5S",
                        F: function(baseRate, name) {
                            if(this.boostdaySystem["blow"].includes(name))
                                return Math.min(baseRate + 5, 100)
                            else
                                return baseRate
                        }
                    },{
                        T: "5% Shoot UP",
                        V: "5R",
                        F: function(baseRate, name) {
                            if(this.boostdaySystem["shot"].includes(name))
                                return Math.min(baseRate + 5, 100)
                            else
                                return baseRate
                        }
                    }, {
                        T: "5% Tech UP",
                        V: "5T",
                        F: function(baseRate, name) {
                            if(this.boostdaySystem["mind"].includes(name))
                                return Math.min(baseRate + 5, 100)
                            else
                                return baseRate
                        }
                    } , {
                        T: "5% HP&PP UP",
                        V: "5H",
                        F: function(baseRate, name) {
                            if(this.boostdaySystem["hppp"].includes(name))
                                return Math.min(baseRate + 5, 100)
                            else
                                return baseRate
                        }
                    } , {
                        T: "5% Special UP",
                        V: "5Sp",
                        F: function(baseRate, name) {
                            if(this.boostdaySystem["sp"].includes(name))
                                return Math.min(baseRate + 5, 100)
                            else
                                return baseRate
                        }
                    }]
                }),
                displayField: "T",
                forceSelection: true,
                editable: false,
                queryMode: "local",
                valueField: "V",
                value: 0,
                typeAhead: true,
                width: 115,
                listeners: {
                    scope: synComp,
                    change: function(combobox, newValue, prevValue) {
                        var resultPanels = this.tabPanel.query("resultpanel"),
                            k;
                        this.enableBoost = (0 != newValue);
                        this.boostDayFunction = combobox.store.findRecord("V", newValue).get("F");
                        if (this.enableBoost) {
                            combobox.addCls("x-campaign-up")
                        } else {
                            combobox.removeCls("x-campaign-up")
                        }
                        if (Ext.isArray(resultPanels)) {
                            for (k = 0; k < resultPanels.length; k++) {
                                resultPanels[k].boostDayFunction = this.boostDayFunction;
                                if (resultPanels[k].rendered) {
                                    resultPanels[k].refresh()
                                }
                            }
                        }
                    }
                }
            }))
        }
        if (synComp.noDD !== true && Ext.isFunction(synComp.getRecommendRecipe)) {
            buttons.push("-");
            buttons.push({
                iconCls: "x-recommend-menu-icon",
                style: {
                    overflow: "visible"
                },
                text: "レシピ例(仮)",
                menu: synComp.getRecommendRecipe()
            })
        }
        // Share button
        if (synComp.noDD !== true) {
            buttons.push("-");
            buttons.push({
                iconCls: "x-share-icon",
                handler: function() {
                    var site = location,
                        link = site.protocol + "//" + site.host + site.pathname + "#!" + lzbase62.compress(site.hash.substring(3));
                    Ext.create("widget.window", {
                        title: "Share",
                        modal: true,
                        width: synComp.noDD === true ? Ext.getBody().getWidth() : 700,
                        height: 500,
                        layout: "fit",
                        autoDestroy: true,
                        closable: true,
                        items: [{
                            xtype: "panel",
                            anchor: "100%",
                            style: {
                                padding: "5px"
                            },
                            height: 32,
                            html: 'Your long link is: <A HREF="' + link + '">' + link + 
                            '</a><br><A HREF="http://api.bit.ly/v3/shorten?login=aidaenna&format=txt&apiKey=R_939fc6c1e5a540f9aa4e710bc4512154&longUrl=' + 
                            link.replace("#!","%23%21") + 
                            '">You can share a short version of this URL by clicking here.</A>'
                            +'<br>Copy the URL it provides in the new window.<br>You can share via Twitter here:'+
                            ' <a href="https://twitter.com/share" class="twitter-share-button" data-url="' + 
                            link + '" data-text="PSO2 Affix Simulation"></a><br><center>',
							//html: '<a href="https://twitter.com/share" class="twitter-share-button" data-url="' + h + '" data-text="PSO2 Skill Simulation"></a>',
                            listeners: {
                                single: true,
                                afterrender: function() {
                                    if (Ext.query("#twitter-wjs").length) {
                                        Ext.query("#twitter-wjs")[0].remove()
                                    }! function(doc, tag, id) {
                                        var n, l = doc.getElementsByTagName(tag)[0],
                                            http = /^http:/.test(doc.location) ? "http" : "https";
                                        if (!doc.getElementById(id)) {
                                            n = doc.createElement(tag);
                                            n.id = id;
                                            n.src = http + "://platform.twitter.com/widgets.js";
                                            l.parentNode.insertBefore(n, l)
                                        }
                                    }(document, "script", "twitter-wjs")
                                }
                            }
                        }, /*{
                            xtype: "textarea",
                            anchor: "100%",
                            layout: "fit",
                            value: h,
                            style: {
                                margin: "5px"
                            }
                        }*/],
                        dockedItems: [{
                            xtype: "toolbar",
                            ui: "footer",
                            dock: "bottom",
                            layout: {
                                pack: "center"
                            },
                            items: Ext.create("Ext.button.Button", {
                                text: "Close",
                                scope: synComp,
                                handler: function() {
                                    Ext.WindowMgr.getActive().close()
                                },
                                minWidth: 105
                            })
                        }]
                    }).show()
                }
            })
            buttons.push({                
				text: " Changelog",
                handler: function() {
                    var site = location,
                        link = site.protocol + "//" + site.host + site.pathname + "#!" + lzbase62.compress(site.hash.substring(3));
                    Ext.create("widget.window", {
                        title: "Changelog",
                        modal: true,
                        width: synComp.noDD === true ? Ext.getBody().getWidth() : 700,
                        height: 500,
                        layout: "fit",
                        autoDestroy: true,
                        closable: true,
                        items: [{
                            xtype: "panel",
                            anchor: "100%",
                            style: {
                                padding: "5px"
                            },
                            height: 32,
                            html: '<b><u>Changelog</b></u></center><br>' +
                            '<b>10/10/2018:</b>'+
                            '<br>- Add New Abilities (Double Reverie, Mark Receptor, SSA)' +
                            '<br>- Remove Abilities add via items since they are not inheritable and reduce clutter' +
                            '<br>- Fix Fabula/Historia not boosting Apprenzina'+
                            '<br>- Fix SSA taking upslot penalty'+
                            '<br>- Add Boost Day System'+
                            '<br>- Create Receptor Tab'+
                            '<br>- Add Whale Item (+50% Booster, Mark Receptor)'+
                            '<br>- Deprecate Calculate Cost Tab' +
                            '<br>- Tons of under the hood stuff'+
                            '<br><br><b>4/12/2018:</b>'+
                            '<br>- Added Loser Reverie<br>'+
                            '<br><b>4/5/2018:</b>'+
                            '<br>- Added the changelog<br>'+
                            '- Added shortlinking via bitly (can\'t do it in the javascript because fuck you java)'+
                            '<br>- Fixed errors with Historia/Fabula tooltips'+
                            '<br>- Fixed Offensive/Defensive Boost stats not showing correctly<br>- Fixed Mark Angar, Sim, and Couragena issues<br>'+
                            '<br><b>6/7/2018:</b>'+
                            '<br>- Added Lesser/EV<br>- Added new SSAs<br>- Fixed some bugs',
                            listeners: {
                                single: true,
                                afterrender: function() {
                                    if (Ext.query("#twitter-wjs").length) {
                                        Ext.query("#twitter-wjs")[0].remove()
                                    }! function(doc, tag, id) {
                                        var n, l = doc.getElementsByTagName(tag)[0],
                                            http = /^http:/.test(doc.location) ? "http" : "https";
                                        if (!doc.getElementById(id)) {
                                            n = doc.createElement(tag);
                                            n.id = id;
                                            n.src = http + "://platform.twitter.com/widgets.js";
                                            l.parentNode.insertBefore(n, l)
                                        }
                                    }(document, "script", "twitter-wjs")
                                }
                            }
                        }, /*{
                            xtype: "textarea",
                            anchor: "100%",
                            layout: "fit",
                            value: h,
                            style: {
                                margin: "5px"
                            }
                        }*/],
                        dockedItems: [{
                            xtype: "toolbar",
                            ui: "footer",
                            dock: "bottom",
                            layout: {
                                pack: "center"
                            },
                            items: Ext.create("Ext.button.Button", {
                                text: "Close",
                                scope: synComp,
                                handler: function() {
                                    Ext.WindowMgr.getActive().close()
                                },
                                minWidth: 105
                            })
                        }]
                    }).show()
                }
            })
        }
        synComp.mainPanel = Ext.create("Ext.panel.Panel", {
            region: "center",
            layout: "fit",
            items: synComp.tabPanel,
            dockedItems: {
                xtype: "toolbar",
                items: buttons
            },
            listeners: {
                scope: synComp,
                afterrender: synComp.onChangeLocationHash
            }
        });
        viewportData.push(synComp.mainPanel);
        Ext.create("Ext.Viewport", {
            renderTo: synComp.outputViewport ? Ext.get(synComp.outputViewport) : Ext.getBody(),
            layout: "border",
            items: viewportData
        });
        synComp.initGridMenuButton();
        window.onhashchange = function() {
            synComp.onChangeLocationHash()
        }
    },
    // Initialize the menu in the fodder panel section
    initGridMenuButton: function() {
        var synComp = this,
            buttons = [];
        buttons.push({
            iconCls: "x-factor-icon",
            text: synComp.factorMenuText.on,
            scope: synComp,
            handler: function(menuItem, event) {
                var cell = this.selectedGridCell;
                if (cell) {
                    var affixEntry = cell.record.get("slot");
                    if (menuItem.text === this.factorMenuText.on) {
                        cell.view.store.each(function(slot, index) {
                            var affixEntry = slot.get("slot");
                            if (affixEntry != null && affixEntry.factor === true) {
                                slot.set("slot", this.makeFactor(affixEntry, false));
                                return false
                            }
                            return true
                        }, this);
                        cell.record.set("slot", this.makeFactor(affixEntry, true))
                    } else {
                        cell.record.set("slot", this.makeFactor(affixEntry, false))
                    }
                }
                this.selectedGridCell = null
            }
        });
        for (var index = 0; index < synComp.maxMaterial; index++) {
            buttons.push({
                iconCls: "x-copy-icon",
                text: "",
                scope: synComp,
                btnIndex: index,
                handler: synComp.onCopyAbility
            })
        }
        buttons.push({
            iconCls: "x-del-icon",
            text: "Delete",
            scope: synComp,
            handler: function() {
                var cell = this.selectedGridCell;
                if (cell) {
                    cell.view.getStore().removeAbility(cell.record, cell.rowIndex);
                    cell.view.refresh()
                }
                this.selectedGridCell = null
            }
        });
        synComp.gridMenu = Ext.create("Ext.menu.Menu", {
            items: buttons
        })
    },
    urlHashValidate: function(panelCode) {
        var synComp = this,
            codeArray = synComp.hasharray(panelCode),
            len = codeArray.length;
        if (!panelCode.s && panelCode.s !== "") {
            return false
        }
        for (var index = 1; index < synComp.maxMaterial; index++) {
            if (!panelCode[index] && panelCode[index] !== "") {
                return false
            }
        }
        for (var index = 0; index < len; index++) {
            if (codeArray[index]) {
                if (!synComp.ability.isExistAbilities(codeArray[index].split("."))) {
                    return false
                }
            }
        }
        return true
    },
    addTab: function(panelData) {
        var synComp = this,
            panels = [{
                xtype: "panel",
                frame: true,
                items: {
                    xtype: "fieldset",
                    layout: "anchor",
                    title: "Select Abilities",
                    autoHeight: true,
                    padding: "0 0 0 4",
                    margin: "0 0 0 0",
                    defaults: {
                        xtype: "checkbox",
                        anchor: "100%",
                        hideEmptyLabel: true,
                        scope: synComp,
                        handler: synComp.onCheckAbility
                    }
                }
            }],
            a = {};
        if (synComp.ajaxData) {
            if (synComp.ajaxData.optionList && synComp.ajaxData.optionList.support) {
                a.supportData = synComp.ajaxData.optionList.support
            }
            if (synComp.ajaxData.optionList && synComp.ajaxData.optionList.additional) {
                a.additionalData = synComp.ajaxData.optionList.additional
            }
            if (synComp.ajaxData.optionList && synComp.ajaxData.optionList.additional) {
                a.potentialData = synComp.ajaxData.optionList.potential
            }
            if (synComp.ajaxData.sameBonusBoost) {
                a.sameBonusBoost = synComp.ajaxData.sameBonusBoost
            }
            if (synComp.ajaxData.excludePattern && synComp.ajaxData.excludePattern.select) {
                a.excludePattern = synComp.ajaxData.excludePattern.select
            }
            if (synComp.ajaxData.excludePattern && synComp.ajaxData.excludePattern.addition) {
                synComp.ability.excludePattern = synComp.ajaxData.excludePattern.addition
            }
            if (synComp.ajaxData.boostdaySystem) {
                a.boostdaySystem = synComp.ajaxData.boostdaySystem
            }
        }
        panels.push(Ext.create("PSO2.ResultPanel", Ext.apply({
            frame: true,
            noDD: synComp.noDD,
            abilityComponent: synComp.ability,
            boostFunction: synComp.enableBoost ? synComp.boostFunction : null,
            boostDayFunction: synComp.enableBoost ? synComp.boostDayFunction : null,
            listeners: {
                scope: synComp,
                opt1change: function(resultPanel, comboBox, isDefault) {
                    if (!resultPanel.suspendCheckChange) {
                        this.onAbilityOptionChange(resultPanel, comboBox, isDefault)
                    }
                },
                opt2change: function(resultPanel, comboBox, isDefault) {
                    if (!resultPanel.suspendCheckChange) {
                        this.onAbilityOptionChange(resultPanel, comboBox, isDefault);
                        this.updateCheckbox(resultPanel, this.tabPanel.activeTab.query("fieldset")[0])
                    }
                },
                opt3change: function(resultPanel, comboBox, isDefault) {
                    if (!resultPanel.suspendCheckChange) {
                        this.onAbilityOptionChange(resultPanel, comboBox, isDefault)
                    }
                }
            }
        }, a)));
        var panel = Ext.create("Ext.panel.Panel", {
            flex: 1,
            frame: true,
            border: false,
            autoScroll: true,
            margin: "0 0 0 0",
            padding: "0 0 0 0",
            layout: "column",
            defaults: {
                columnWidth: 1 / 2,
                layout: "anchor",
                autoHeight: true,
                defaults: {
                    anchor: "100%"
                }
            },
            items: panels,
            getFieldSet: function() {
                var panel = this;
                if (!panel.fieldSet) {
                    panel.fieldSet = panel.query("fieldset")[0]
                }
                return panel.fieldSet
            },
            getResultPanel: function() {
                var panel = this;
                if (!panel.resultPanel) {
                    panel.resultPanel = panel.query("resultpanel")[0]
                }
                return panel.resultPanel
            },
            updateResults: function() {
                if (synComp.initializedRestoreData !== true) {
                    var fieldSet = this.getFieldSet(),
                        resultPanel = this.getResultPanel();
                    resultPanel.updateResults(fieldSet)
                }
            }
        });
        // Load up the checkboxes from save
        if (synComp.initializedRestoreData === true) {
            var fieldSet = panel.getFieldSet(),
                resultPanel = panel.getResultPanel();
            fieldSet.on("afterrender", function(p, delayEventData) {
                var t = this,
                    selectedCode = panelData.r;
                panel.updateResults();
                if (selectedCode) {
                    var codeArray = selectedCode.split("."),
                        checkBoxes = t.query("checkbox"),
                        len;
                    delayEventData.myComponent.initializedCheckbox = false;
                    if (Ext.isArray(checkBoxes) && (len = checkBoxes.length) > 0) {
                        for (var index = 0; index < len; index++) {
                            if (0 <= Ext.Array.indexOf(codeArray, checkBoxes[index].inputValue)) {
                                checkBoxes[index].setValue(true)
                            }
                        }
                    }
                    delayEventData.myComponent.initializedCheckbox = true
                }
            }, fieldSet, {
                delay: 1000,
                myComponent: synComp
            });
            // Load all the item selected in the comboboxes
            resultPanel.on("afterrender", function(q, delayEventData) {
                var s = this,
                    comboBoxSelectedCode = panelData.o;
                if (comboBoxSelectedCode) {
                    var codeArray = comboBoxSelectedCode.split("."),
                        len = codeArray.length;
                    delayEventData.myComponent.initializedSelectOption = false;
                    for (var index = 0; index < len; index++) {
                        s.selectOption(codeArray[index])
                    }
                    delayEventData.myComponent.initializedSelectOption = true
                }
            }, resultPanel, {
                delay: 1000,
                myComponent: synComp
            })
        }
        var foddersGrid = [synComp.createGridPanel(0, synComp.ability.createSlotStore(), panel, panelData ? panelData.s : null)];
        for (var e = 1; e <= synComp.maxMaterial; e++) {
            foddersGrid.push(synComp.createGridPanel(e, synComp.ability.createSlotStore(), panel, panelData ? panelData[e] : null))
        }
        var synPanel = synComp.tabPanel.add({
            title: "Synthesis Panel",
            autoScroll: true,
            closable: true,
            fillDuster: function() {
                var gridPanels = this.query("gridpanel"), maxSlots = 0;
                for (var index = 0; index < gridPanels.length; index++) {
                    maxSlots = Math.max(maxSlots, gridPanels[index].getAbilityCount())
                }
                synComp.initializedRestoreData = true;
                try {
                    for (var index = 0; index < gridPanels.length; index++) {
                        if (index == 0) {
                            gridPanels[index].fillDuster(maxSlots)
                        } else {
                            if (0 < gridPanels[index].getAbilityCount()) {
                                gridPanels[index].fillDuster(maxSlots)
                            }
                        }
                    }
                } finally {
                    synComp.initializedRestoreData = false
                }
                panel.updateResults();
                synComp.onChangeAbility()
            },
            layout: {
                type: "vbox",
                align: "stretch",
                padding: "0 0 5 0"
            },
            items: [{
                layout: "column",
                defaults: {
                    columnWidth: 1 / (synComp.maxMaterial + 1),
                    layout: "anchor",
                    autoHeight: true,
                    defaults: {
                        anchor: "100%"
                    }
                },
                items: foddersGrid
            }, panel],
            getResultPanel: panel.getResultPanel
        });
        synComp.addLocationHash(synPanel);
        if (synComp.initializedRestoreData !== true) {
            synComp.updateLocationHash()
        }
        return synPanel
    },
    // Save data onto a cookie
    saveData: function() {
        var synComp = this;
        if (synComp.tabPanel.activeTab) {
            var tabIndex = synComp.findLocationHashBy(synComp.tabPanel.activeTab);
            if (0 <= tabIndex) {
                var tabData = synComp.locationHash[tabIndex];
                if (synComp.urlHashValidate(tabData)) {
                    return Ext.Msg.prompt("Save Panel", "Panel state was saved to a cookie.<br/>Input a name?", function(okButton, textfield) {
                        if (okButton == "ok") {
                            var savedCookie = PSO2.Cookie.get(synComp.constCookieName) || {},
                                tabHash = {};
                            if (textfield == "") {
                                textfield = Ext.Date.format(new Date(), "Y-m-d H:i:s")
                            }
                            synComp.hashcopy(synComp.locationHash[tabIndex], tabHash);
                            if (savedCookie[textfield]) {
                                Ext.Msg.confirm("Confirm", "Data of the same name exists. Overwrite?", function(yesButton) {
                                    if (yesButton == "yes") {
                                        savedCookie[textfield] = tabHash;
                                        PSO2.Cookie.set(synComp.constCookieName, savedCookie);
                                        Ext.Msg.alert("Information", "Save complete.")
                                    }
                                }, synComp)
                            } else {
                                savedCookie[textfield] = tabHash;
                                PSO2.Cookie.set(synComp.constCookieName, savedCookie);
                                Ext.Msg.alert("Information", "Save complete.")
                            }
                        }
                    }, synComp)
                }
            }
        }
        return Ext.Msg.alert("Save Panel", "There is nothing to save.")
    },
    // Load data from a cookie
    loadData: function() {
        var synComp = this,
            savedCookies = PSO2.Cookie.get(synComp.constCookieName);
        if (savedCookies && Ext.isObject(savedCookies)) {
            var cookieMap = [],
            a;
            for (var e in savedCookies) {
                cookieMap.unshift({
                    key: e,
                    value: savedCookies[e]
                })
            }
            if (synComp.noDD === true) {
                a = {
                    scope: synComp,
                    itemclick: function(dataView, cookie) {
                        this.selectLoadData(dataView, cookie);
                        Ext.WindowMgr.getActive().close()
                    }
                }
            } else {
                a = {
                    scope: synComp,
                    itemdblclick: function(dataView, cookie) {
                        this.selectLoadData(dataView, cookie);
                        Ext.WindowMgr.getActive().close()
                    }
                }
            }
            Ext.create("widget.window", {
                title: "Load Panel",
                modal: true,
                width: synComp.noDD === true ? Ext.getBody().getWidth() : 600,
                height: 320,
                layout: "fit",
                autoDestroy: true,
                closable: true,
                items: Ext.create("Ext.view.View", {
                    anchor: "100%",
                    autoScroll: true,
                    allowBlank: false,
                    store: Ext.create("Ext.data.Store", {
                        model: "PSO2.CookieModel",
                        data: cookieMap
                    }),
                    tpl: ['<tpl for=".">', '<div class="cookie-wrap">', '<div class="cookie">{key}</div>', "</div>", "</tpl>", '<div class="x-clear"></div>'],
                    listeners: a,
                    trackOver: true,
                    overItemCls: "x-item-over",
                    itemSelector: "div.cookie-wrap"
                }),
                dockedItems: [{
                    xtype: "toolbar",
                    ui: "footer",
                    dock: "bottom",
                    layout: {
                        pack: "center"
                    },
                    items: Ext.create("Ext.button.Button", {
                        text: "Close",
                        scope: synComp,
                        handler: function() {
                            Ext.WindowMgr.getActive().close()
                        },
                        minWidth: 105
                    })
                }]
            }).show()
        } else {
            Ext.Msg.alert("Load Panel", "Panel was not restored.");
        }
    },
    // Load data onto a tab
    selectLoadData: function(b, cookie) {
        var synComp = this;
        if (cookie) {
            var value, synPanel, c;
            if (Ext.isFunction(cookie.get)) {
                value = cookie.get("value")
            } else {
                value = cookie
            }
            synComp.initializedRestoreData = true;
            try {
                synPanel = synComp.addTab(value)
            } finally {
                synComp.initializedRestoreData = false
            }
            synComp.hashcopy(value, synComp.addLocationHash(synPanel));
            synComp.updateLocationHash();
            synComp.tabPanel.setActiveTab(synPanel)
        }
    },
    // Store value of all options selected in the comboboxes (except default)
    onAbilityOptionChange: function(resultPanel, combobox, isDefault) {
        var synComp = this,
            tabIndex = synComp.findLocationHashBy(synComp.tabPanel.activeTab),
            codeHead = combobox.value.charAt(0);
        if (synComp.locationHash[tabIndex]) {
            var codeList = synComp.locationHash[tabIndex]["o"].split("."),
                selectOptions = [];
            Ext.Array.forEach(codeList, function(code) {
                if (0 < code.length && code.charAt(0) != codeHead) {
                    selectOptions.push(code)
                }
            });
            // Do not save the default option
            if (!isDefault) {
                selectOptions.push(combobox.value)
            }
            synComp.locationHash[tabIndex]["o"] = selectOptions.join(".");
            synComp.updateLocationHash()
        }
    },
    makeFactor: function(affixData, isFactor) {
        var slotData;
        if (isFactor == true) {
            slotData = Ext.applyIf({
                source: affixData,
                factor: true,
                extend: null,
                generate: null
            }, affixData);
            slotData.code = "*" + affixData.code
        } else {
            slotData = affixData.source;
            delete affixData
        }
        return slotData
    },
    createGridPanel: function(index, store, panel, codeString) {
        var synComp = this,
            fodderPanel, resultPanel = panel.getResultPanel(),
            g, indexList = [];
        for (i = 0; i <= synComp.maxMaterial; i++) {
            if (i != index) {
                indexList.push(i)
            }
        }
        resultPanel.bindStore(store);
        store.on({
            scope: panel,
            update: panel.updateResults
        });
        store.on({
            scope: synComp,
            update: synComp.onChangeAbility
        });
        fodderPanel = Ext.create("Ext.grid.Panel", {
            title: synComp.panelNames[index],
            titleIndex: indexList,
            sortableColumns: false,
            dustAbilities: synComp.ability.abilityStore.getRange(synComp.ability.abilityStore.find("gid", "ZZ")),
            getAbilityCount: function() {
                var m = this.store;
                return m.getEnableData().length - m.getFactorCount();
            },
            locked: false,
            collapsed: false,
            collapsible: true,
            collapseCls: "-collapse-",
            lockedCls: "slot-grid-locked",
            listeners: {
                scope: synComp,
                beforecollapse: function(fodderTitleBar, q, m, o) {
                    if (fodderTitleBar.tools[0] && fodderTitleBar.tools[0].rendered) {
                        var n = fodderTitleBar.tools[0];
                        if (fodderTitleBar.locked === true) {
                            n.toolEl.removeCls(n.componentCls + fodderTitleBar.collapseCls + n.expandType);
                            n.toolEl.addCls(n.componentCls + fodderTitleBar.collapseCls + fodderTitleBar.collapseDirection);
                            fodderTitleBar.el.removeCls(fodderTitleBar.lockedCls)
                        } else {
                            n.toolEl.removeCls(n.componentCls + fodderTitleBar.collapseCls + fodderTitleBar.collapseDirection);
                            n.toolEl.addCls(n.componentCls + fodderTitleBar.collapseCls + n.expandType);
                            fodderTitleBar.el.addCls(fodderTitleBar.lockedCls)
                        }
                        fodderTitleBar.locked = !fodderTitleBar.locked
                    }
                    return false
                }
            },
            fillDuster: function(minAffix) {
                var count, slot;
                minAffix = Math.min(minAffix + this.store.getFactorCount(), this.store.getCount());
                if (this.getAbilityCount() <= minAffix) {
                    count = 0;
                    while (count < minAffix && (slot = this.store.getAt(count).get("slot")) != null) {
                        if (slot.gid == "ZZ") {
                            this.store.removeAbility(slot, count)
                        } else {
                            count++
                        }
                    }
                    for (var index = count = 0; count < minAffix; count++) {
                        slot = this.store.getAt(count).get("slot");
                        if (slot == null) {
                            this.store.addAbility(this.dustAbilities[index++].data)
                        }
                    }
                    this.view.refresh()
                }
            },
            columns: [{
                dataIndex: "name",
                header: "Slot",
                width: 52,
                hidden: synComp.noDD || 2 < synComp.maxMaterial
            }, {
                dataIndex: "slot",
                header: "Ability",
                renderer: function(slotData, n, slot, r, p, o) {
                    if (slotData != null) {
                        if (slotData.factor) {
                            n.tdCls = "x-factor-icon"
                        }
                        return slotData.name
                    }
                    return ""
                }
            }],
            forceFit: true,
            store: store,
            viewConfig: {
                listeners: synComp.initDDListener(synComp.noDD)
            }
        });
        if (codeString) {
            var abStore = synComp.ability.getAbilityStore();
            Ext.Array.forEach(codeString.split("."), function(n) {
                var isSAF = (n.substr(0, 1) == "*"),
                    affixEntry = abStore.findRecord("code", isSAF ? n.substr(1) : n);
                if (affixEntry) {
                    fodderPanel.store.addAbility(isSAF ? synComp.makeFactor(affixEntry.data, true) : affixEntry.data)
                }
            })
        }
        return fodderPanel
    },
    // Creates the dropdown menu
    initDDListener: function(noDD) {
        var synComp = this,
            dropDown = {
                scope: synComp
            };
        if (noDD !== true) {
            dropDown.render = synComp.initializeSlotDropZone;
            dropDown.cellcontextmenu = function(gridView, n, k, slot, o, rowIndex, event) {
                event.stopEvent();
                if (slot.get("slot") != null) {
                    synComp.selectedGridCell = {
                        view: gridView,
                        record: slot,
                        rowIndex: rowIndex
                    };
                    if (slot.get("slot").factor !== true) {
                        synComp.gridMenu.items.getAt(0).setText(synComp.factorMenuText.on)
                    } else {
                        synComp.gridMenu.items.getAt(0).setText(synComp.factorMenuText.off)
                    }
                    var fodderArray = [];
                    Ext.Array.forEach(this.tabPanel.getActiveTab().query("grid"), function(gridPanel) {
                        if (gridPanel.getView() !== gridView) {
                            fodderArray.push(gridPanel)
                        }
                    });
                    for (var index = 0; index < synComp.maxMaterial; index++) {
                        synComp.copyButtonUpdate(gridView, synComp.gridMenu.items.getAt(index + 1), index, fodderArray[index])
                    }
                    synComp.gridMenu.showAt(event.getXY())
                }
            }
        } else {
            dropDown.cellclick = function(gridView, d, h, slot, m, rowIndex, event) {
                event.stopEvent();
                if (gridView.panel && gridView.panel.locked === true) {
                    return false
                }
                synComp.selectedGridCell = {
                    view: gridView,
                    record: slot,
                    rowIndex: rowIndex
                };
                if (slot.get("slot") != null) {
                    if (slot.get("slot").factor !== true) {
                        synComp.gridMenu.items.getAt(0).setText(synComp.factorMenuText.on)
                    } else {
                        synComp.gridMenu.items.getAt(0).setText(synComp.factorMenuText.off)
                    }
                    var fodderArray = [];
                    Ext.Array.forEach(this.tabPanel.getActiveTab().query("grid"), function(gridPanel) {
                        if (gridPanel.getView() !== gridView) {
                            fodderArray.push(gridPanel)
                        }
                    });
                    for (i = 0; i < synComp.maxMaterial; i++) {
                        synComp.copyButtonUpdate(gridView, synComp.gridMenu.items.getAt(i + 1), i, fodderArray[i])
                    }
                    synComp.gridMenu.showAt(event.getXY())
                } else {
                    synComp.abilityWindow.setWidth(synComp.mainPanel.getWidth());
                    synComp.abilityWindow.setHeight(Ext.getBody().getHeight());
                    synComp.abilityWindow.showAt(0, 0)
                }
            }
        }
        return dropDown
    },
    copyButtonUpdate: function(gridView, menuItem, titleIndex, gridPanel) {
        var synComp = this,
            panelOwner = gridView.ownerCt;
        menuItem.setText("Copy to " + synComp.panelNames[panelOwner.titleIndex[titleIndex]]);
        menuItem.targetView = gridPanel;
        return menuItem
    },
    // Excute copy to fodder action
    onCopyAbility: function(action) {
        var synComp = this,
            selCell = synComp.selectedGridCell;
        if (selCell && action.targetView) {
            action.targetView.getStore().addAbility(selCell.record.get("slot"))
        }
        this.selectedGridCell = null
    },

    initializeAbilityDragZone: function(gridView) {
        gridView.dragZone = Ext.create("Ext.dd.DragZone", gridView.getEl(), {
            getDragData: function(event) {
                var targetItem = event.getTarget(gridView.itemSelector, 10),
                    clone;
                if (targetItem) {
                    clone = targetItem.cloneNode(true);
                    clone.id = Ext.id();
                    return gridView.dragData = {
                        gridId: this.id,
                        sourceEl: targetItem,
                        repairXY: Ext.fly(targetItem).getXY(),
                        ddel: clone,
                        patientData: gridView.getRecord(targetItem).data
                    }
                }
            },
            getRepairXY: function() {
                return this.dragData.repairXY
            }
        })
    },
    initializeSlotDropZone: function(inGridView) {
        var synComp = this,
            gridView = inGridView,
            gridPanel = gridView.up("gridpanel");
        inGridView.dragZone = Ext.create("Ext.dd.DragZone", inGridView.getEl(), {
            getDragData: function(g) {
                var targetItem = g.getTarget(inGridView.itemSelector, 10),
                    clone;
                if (targetItem) {
                    if (!inGridView.getRecord(targetItem).data.slot) {
                        return null
                    }
                    clone = targetItem.cloneNode(true);
                    clone.id = Ext.id();
                    return inGridView.dragData = {
                        gridId: this.id,
                        sourceEl: targetItem,
                        repairXY: Ext.fly(targetItem).getXY(),
                        ddel: clone,
                        patientData: inGridView.getRecord(targetItem).data.slot
                    }
                }
            },
            beforeInvalidDrop: function(event, g, l) {
                var source = this.dragData.sourceEl,
                    sourceRecord = inGridView.getRecord(source);
                if (sourceRecord && !Ext.get(event) && !gridView.panel.locked) {
                    sourceRecord.store.removeAbility(sourceRecord, source.viewIndex);
                    inGridView.refresh();
                    this.proxy.hide()
                }
            },
            getRepairXY: function() {
                return this.dragData.repairXY
            }
        });
        gridPanel.dropZone = Ext.create("Ext.dd.DropZone", inGridView.el, {
            getTargetFromEvent: function(event) {
                return event.getTarget(".x-grid-cell-last")
            },
            onNodeDrop: function(htmlCellEle, dragZone, event, gridView) {
                if (inGridView.panel && inGridView.panel.locked) {
                    return true
                }
                if (this.id == gridView.gridId) {
                    inGridView.getStore().swapAbility(gridView.sourceEl.viewIndex, event.getTarget(gridView.itemSelector).viewIndex);
                    inGridView.refresh();
                    synComp.onChangeAbility()
                } else {
                    inGridView.getStore().addAbility(gridView.patientData)
                }
                return true
            }
        })
    },
    onChangeAbility: function() {
        var synComp = this,
            synPanel, resultPanel, abSet, panelIndex;
        if (synComp.initializedRestoreData !== true) {
            synPanel = this.tabPanel.activeTab;
            resultPanel = synPanel && synPanel.query("resultpanel")[0];
            abSet = resultPanel && resultPanel.abilitySet;
            panelIndex = synComp.findLocationHashBy(synPanel);
            if (abSet && synComp.locationHash[panelIndex]) {
                synComp.locationHash[panelIndex]["s"] = abSet.getLocationHash(0).join(".");
                for (var c = 0; c <= synComp.maxMaterial; c++) {
                    synComp.locationHash[panelIndex][c] = abSet.getLocationHash(c).join(".")
                }
                synComp.locationHash[panelIndex]["r"] = resultPanel.getValues().join(".");
                synComp.updateLocationHash()
            }
        }
    },
    // Add/Removes ability from result panel when checkbox is checked
    onCheckAbility: function(checkBox, isCheck) {
        var synComp = this,
            resultPanel = checkBox.resultPanel;
        if (resultPanel) {
            if (isCheck) {
                resultPanel.addAbility(checkBox)
            } else {
                resultPanel.removeAbility(checkBox)
            }
            synComp.updateCheckbox(resultPanel, checkBox.fieldSet);
            if (synComp.tabPanel.activeTab) {
                var panelIndex = synComp.findLocationHashBy(synComp.tabPanel.activeTab);
                if (0 <= panelIndex) {
                    synComp.locationHash[panelIndex]["r"] = resultPanel.getValues().join(".");
                    synComp.updateLocationHash()
                }
            }
        }
    },
    // Enable/disable checkbox if max is reach
    updateCheckbox: function(resultPanel, fieldSet) {
        var checkboxArray = fieldSet.query("checkbox");
        if (resultPanel.abilityCount() < resultPanel.getEnableMaxCount()) {
            Ext.Array.forEach(checkboxArray, function(checkbox) {
                if (checkbox.disabled) {
                    checkbox.enable()
                }
            })
        } else {
            Ext.Array.forEach(checkboxArray, function(checkbox) {
                if (!checkbox.checked) {
                    checkbox.disable()
                }
            })
        }
    },
    // returns index of the panel in the hash
    findLocationHashBy: function(synPanel) {
        var synComp = this,
            hashLen = synComp.locationHash.length,
            index;
        for (index = 0; index < hashLen; index++) {
            if (synComp.locationHash[index]["id"] == synPanel.id) {
                return index
            }
        }
        return -1
    },
    // Add hash for a new panel
    addLocationHash: function(synPanel, urlLimit) {
        var synComp = this,
            locHash, index;
        if (synComp.initializedRestoreData === true && urlLimit !== true) {
            return location.hash
        }
        synComp.locationHash = synComp.locationHash || [];
        locHash = {
            id: synPanel.id,
            s: "",
            r: "",
            o: ""
        };
        for (index = 1; index <= synComp.maxMaterial; index++) {
            locHash[index] = ""
        }
        synComp.locationHash.push(locHash);
        return locHash
    },
    // Removes hash when panel is deleted
    removeLocationHash: function(synPanel) {
        var synComp = this,
            panelIndex = synComp.findLocationHashBy(synPanel),
            panelHash;
        if (synComp.initializedRestoreData === true) {
            return location.hash
        }
        if (0 <= panelIndex) {
            panelHash = synComp.locationHash.splice(panelIndex, 1)
        }
        synComp.updateLocationHash();
        return panelHash
    },
    updateLocationHash: function() {
        var synComp = this,
            instanceHash = "",
            hashLen = synComp.locationHash.length,
            index;
        if (synComp.initializedRestoreData !== true && synComp.initializedCheckbox !== false && synComp.initializedSelectOption !== false) {
            if (0 < hashLen) {
                instanceHash = "#!";
                for (index = 0; index < hashLen && index < synComp.limitUrlSize; index++) {
                    instanceHash += "/";
                    instanceHash += synComp.hashmake(synComp.locationHash[index])
                }
            }
            if (location.hash != instanceHash) {
                location.hash = instanceHash
            }
        }
    },
    // Updates url when changes happen
    onChangeLocationHash: function() {
        var synComp = this,
            structHashList = synComp.locationHash || [],
            abStore = synComp.ability.abilityStore;
        if (location && location.hash) {
            if (location.hash.match(/^#!([a-zA-Z0-9]+)$/)) {
                return location.hash = "!/" + lzbase62.decompress(RegExp.$1)
            } else {
                if (location.hash.match(/^#!\/([a-zA-Z0-9\.\=&\/\*]+)/)) {
                    var stringHashList = RegExp.$1.split("/"),
                        m = stringHashList.length,
                        index;
                    for (index = 0; index < m && index < synComp.limitUrlSize; index++) {
                        if (index < structHashList.length) {
                            // Enters an invalid url
                            if (stringHashList[index] != synComp.hashmake(structHashList[index])) {
                                var hashStruct = Ext.urlDecode(stringHashList[index]);
                                if (synComp.urlHashValidate(hashStruct)) {
                                    var symPanel = Ext.getCmp(structHashList[index].id),
                                        resultPanel = symPanel.getResultPanel(),
                                        fieldSet = resultPanel.ownerCt.getFieldSet(),
                                        codes = hashStruct.r.split("."),
                                        fodderArray = symPanel.query("grid"),
                                        recoveryFn = function(panel, codeString) {
                                            var storeCount = panel.store.count(),
                                                codeArray = codeString.split("."),
                                                code, isSAF, affixEntry;
                                            for (var t = 0; t < storeCount; t++) {
                                                code = codeArray.shift();
                                                if (code) {
                                                    isSAF = (code.substr(0, 1) == "*");
                                                    affixEntry = abStore.findRecord("code", isSAF ? code.substr(1) : code);
                                                    if (affixEntry) {
                                                        panel.store.getAt(t).data.slot = (isSAF ? synComp.makeFactor(affixEntry.data, true) : affixEntry.data)
                                                    }
                                                } else {
                                                    panel.store.getAt(t).data.slot = null
                                                }
                                            }
                                            panel.getView().refresh()
                                        };
                                    recoveryFn(fodderArray[0], hashStruct.s);
                                    for (var f = 1; f <= synComp.maxMaterial; f++) {
                                        recoveryFn(fodderArray[f], hashStruct[f])
                                    }
                                    resultPanel.suspendCheckChange = 1;
                                    resultPanel.ownerCt.updateResults();
                                    fieldSet.items.each(function(checkbox) {
                                        checkbox.suspendCheckChange = 1;
                                        if (0 <= codes.indexOf(checkbox.inputValue)) {
                                            checkbox.setValue(true);
                                            resultPanel.addAbility(checkbox, true)
                                        } else {
                                            checkbox.setValue(false);
                                            resultPanel.removeAbility(checkbox, true)
                                        }
                                        checkbox.suspendCheckChange = 0
                                    });
                                    resultPanel.refresh();
                                    synComp.updateCheckbox(resultPanel, fieldSet);
                                    Ext.Array.forEach(hashStruct.o.split("."), function(p) {
                                        resultPanel.selectOption(p)
                                    });
                                    resultPanel.refresh();
                                    synComp.updateCheckbox(resultPanel, fieldSet);
                                    resultPanel.suspendCheckChange = 0;
                                    synComp.hashcopy(hashStruct, structHashList[index])
                                }
                            }
                        } else {
                            var hashStruct = Ext.urlDecode(stringHashList[index]);
                            synComp.initializedRestoreData = true;
                            try {
                                synComp.hashcopy(hashStruct, synComp.addLocationHash(synComp.addTab(hashStruct), true))
                            } finally {
                                synComp.initializedRestoreData = false
                            }
                        }
                    }
                    if (index < structHashList.length) {
                        var a = [];
                        while (index != structHashList.length) {
                            a.push((structHashList.pop())["id"])
                        }
                        Ext.Array.forEach(a, function(s) {
                            var p = Ext.getCmp(s);
                            if (p) {
                                p.close()
                            }
                        })
                    }
                }
            }
        }
    },
    hasharray: function(panelCode) {
        var synComp = this,
            hashStruct = [panelCode.s, panelCode.r];
        for (var index = 1; index <= synComp.maxMaterial; index++) {
            hashStruct.push(panelCode[index])
        }
        return hashStruct
    },
    hashmake: function(d) {
        var synComp = this,
            hashString = "";
        hashString += synComp.makeHashParameter(d, "s");
        for (var index = 1; index <= synComp.maxMaterial; index++) {
            hashString += "&" + synComp.makeHashParameter(d, index)
        }
        hashString += "&" + synComp.makeHashParameter(d, "r");
        hashString += "&" + synComp.makeHashParameter(d, "o");
        return hashString
    },
    hashcopy: function(d, basicPanel) {
        var synComp = this,
            index;
        basicPanel.s = d.s;
        basicPanel.r = d.r;
        basicPanel.o = d.o;
        for (index = 1; index <= synComp.maxMaterial; index++) {
            basicPanel[index] = d[index]
        }
    },
    makeHashParameter: function(hashStruct, field) {
        return field + "=" + (hashStruct[field] ? hashStruct[field] : "")
    }
});
